<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://clownjerome.github.io</id>
    <title>陈思羽</title>
    <updated>2021-10-29T14:14:22.014Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://clownjerome.github.io"/>
    <link rel="self" href="https://clownjerome.github.io/atom.xml"/>
    <subtitle>天道酬勤</subtitle>
    <logo>https://clownjerome.github.io/images/avatar.png</logo>
    <icon>https://clownjerome.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 陈思羽</rights>
    <entry>
        <title type="html"><![CDATA[数据结构-链表]]></title>
        <id>https://clownjerome.github.io/post/shu-ju-jie-gou-lian-biao/</id>
        <link href="https://clownjerome.github.io/post/shu-ju-jie-gou-lian-biao/">
        </link>
        <updated>2021-10-29T14:09:14.000Z</updated>
        <content type="html"><![CDATA[<h3>一、具体用法</h3>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>链表可分为单向链表和双向链表。</p>
<p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1635516618565.png" alt="" loading="lazy"></figure>
<p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p>
<figure data-type="image" tabindex="2"><img src="https://clownjerome.github.io/post-images/1635516627036.png" alt="" loading="lazy"></figure>
<p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p>
<p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。</p>
<h4>以下情况使用 ArrayList :</h4>
<ul>
<li>频繁访问列表中的某一个元素。</li>
<li>只需要在列表末尾进行添加和删除元素操作。</li>
</ul>
<h4>以下情况使用 LinkedList :</h4>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://clownjerome.github.io/post-images/1635516635619.png" alt="" loading="lazy"></figure>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<h3>二、实现方法-代码实现</h3>
<h4>创建链表</h4>
<p>链表中的节点的定义：</p>
<pre><code class="language-java">class Node {
        T data;
        Node next = null;//下一个节点

        public Node(T data) {
            this.data = data;
        }

        public Node() {
        }
    }
</code></pre>
<h4 id="插入元素">插入元素</h4>
<p>首先判断是否是一个空链表，如果是，则创建新链表，并将数据赋值给新节点，否则在末尾追加，或者在中间任意位置处插入。</p>
<ul>
<li>在末尾追加</li>
</ul>
<pre><code class="language-java">public boolean add(T data) {
        Node newNode = new Node(data);
        if (null == head) {
            head = newNode;
            return true;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        length++;
        return true;
    }
</code></pre>
<ul>
<li>在中间任意位置插入</li>
</ul>
<pre><code class="language-java">public boolean insert(int index, T data) {
        Node newNode = new Node(data);
        //if index=1, special opearate
        if (index == 1) {
            if (head == null) { //head is not existed
                head = newNode;
                return true;
            } else { //head is existed
                Node temp = head;
                newNode.next = temp;
                head = newNode;
                return true;
            }
        }
        //index not true -&gt; false
        if (index &lt; 1 || index &gt; this.length()) {
            return false;
        }
        int count = 1;//count the current node
        Node temp = head;
        while (count &lt; index) {
            count += 1;
            temp = temp.next;
        }
        newNode.next = temp.next;
        temp.next = newNode;
        length++;
        return true;
    }
</code></pre>
<h4 id="删除元素">删除元素</h4>
<h5 id="方法1">方法1</h5>
<pre><code class="language-java">Node pre = head;
Node cur = head.next;
while (cur != null) {
    if (cur.data == data) {
        foundNum++;
        pre.next = cur.next;
    }
    pre = cur;
    cur = cur.next;
}
</code></pre>
<h5 id="方法2">方法2</h5>
<pre><code class="language-java">Node temp = head;
while (temp != null) {
    if (temp.data == data) {
        foundNum += 1;

        T tempData = temp.data;
        temp.data = temp.next.data;
        temp.next.data = tempData;
        temp.next = temp.next.next;

        length--;
        return true;
    }
    temp = temp.next;
}
</code></pre>
<h5>整体代码</h5>
<pre><code class="language-java">    /**
     * 删除链表中的节点
     */
    public static ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return null;
        }

        //定义前指针 是为了删除节点
        ListNode pre = null;
        
        //定义next是为了指针后移
        ListNode next;
        
        for (ListNode i = head; i != null; i = next) {
            next = i.next;
            if (i.val == val) {
                //这个判断说明头一个节点，就需要删除，因此头指针后移
                if (head.equals(i)) {
                    head = head.next;
                }

                //前节点next指向后节点
                if (pre != null) {
                    pre.next = i.next;
                }

                i.next = null;
            } else {
                pre = i;
            }
        }

        return head;
    }
</code></pre>
<h4 id="查询元素">查询元素</h4>
<p>对着链表中的元素一个一个遍历，直到找到为止，如果找不到则返回false：</p>
<pre><code class="language-java">public int search(T data) {
        if (length == 0) {
            return -1;
        }
        int index = 0;
        int foundIndex = 0;
        Node temp = head;
        while (temp.next != null) {
            index++;
            if (temp.next.data == data) {
                foundIndex++;
                return index;
            }
            temp = temp.next;
        }
        if (foundIndex == 0)
            return -1;
        return index;
    }
</code></pre>
<h4 id="打印元素">打印元素</h4>
<pre><code class="language-java">public boolean printNode() {
        Node temp = head;
        while (temp.next != null) {
            System.out.print(temp.next.data + &quot;\t&quot;);
            temp = temp.next;
        }
        return true;
    }
</code></pre>
<h4>完整代码</h4>
<pre><code class="language-java">public class MyLinkNode&lt;T&gt; {
    private int length = 0;

    Node head = new Node();

    public Node getHead() {
        return head;
    }

    class Node {
        T data;
        Node next = null;//下一个节点

        public Node(T data) {
            this.data = data;
        }

        public Node() {
        }
    }

    public boolean add(T data) {
        Node newNode = new Node(data);
        if (null == head) {
            head = newNode;
            return true;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        length++;
        return true;
    }

    public boolean insert(int index, T data) {
        Node newNode = new Node(data);
        //if index=1, special opearate
        if (index == 1) {
            if (head == null) { //head is not existed
                head = newNode;
                return true;
            } else { //head is existed
                Node temp = head;
                newNode.next = temp;
                head = newNode;
                return true;
            }
        }
        //index not true -&gt; false
        if (index &lt; 1 || index &gt; this.length()) {
            return false;
        }
        int count = 1;//count the current node
        Node temp = head;
        while (count &lt; index) {
            count += 1;
            temp = temp.next;
        }
        newNode.next = temp.next;
        temp.next = newNode;
        length++;
        return true;
    }

    public boolean printNode() {
        Node temp = head;
        while (temp.next != null) {
            System.out.print(temp.next.data + &quot;\t&quot;);
            temp = temp.next;
        }
        return true;
    }

    public int length() {
        return length;
    }

    public boolean delete(T data) {
        if (head == null) {
            return false;
        }
        int foundNum = 0;
        /*
        方式1：
        使用两个指针，一个指针指向当前指针，一个指针当前指针的前驱，当删除时，直接忽略需要删除的节点即可
         */
        Node pre = head;
        Node cur = head.next;
        while (cur != null) {
            if (cur.data == data) {
                foundNum++;
                pre.next = cur.next;
            }
            pre = cur;
            cur = cur.next;
        }
        /*
        方式2：将要删除的节点(假设要删除的节点的位置3)的下一个节点（位置是4）的数据赋值到当前要删除的节点，
        此时当前节点（位置是3）的数据是下一节点（位置是4）的数据，然后将当前节点（位置是3）的后驱指向一下节点（位置是4）
        的下一节点（位置是5）
         */
//        Node temp = head;
//        while (temp != null) {
//            if (temp.data == data) {
//                foundNum += 1;
//
//                T tempData = temp.data;
//                temp.data = temp.next.data;
//                temp.next.data = tempData;
//                temp.next = temp.next.next;
//
//                length--;
//                return true;
//            }
//            temp = temp.next;
//        }

        if (foundNum == 0) {
            System.out.println(&quot;not found data -&gt;&quot; + data);
            return false;
        }
        length--;
        return true;
    }

    public boolean delete(int index) {
        if (index == 1) {

            Node temp = head;
            head = temp.next;
            System.out.println(head.data + &quot;---&quot; + head.next.toString());
            return true;
        }
        if (index &lt; 1 || index &gt;= this.length()) {
            return false;
        }
        int count = 0;
        Node temp = head;
        while (count &lt; index) {
            count++;
            temp = temp.next;
        }
        temp.next = temp.next.next;
        length--;

        return true;
    }



    public int search(T data) {
        if (length == 0) {
            return -1;
        }
        int index = 0;
        int foundIndex = 0;
        Node temp = head;
        while (temp.next != null) {
            index++;
            if (temp.next.data == data) {
                foundIndex++;
                return index;
            }
            temp = temp.next;
        }
        if (foundIndex == 0)
            return -1;
        return index;
    }

    public boolean update(T oldData, T data) {
        if (length == 0)
            return false;
        int foundNum = 0;
        Node temp = head;
        if (oldData instanceof String) {
            while (temp.next != null) {
                if ((oldData.equals(temp.data))) {
                    foundNum++;
                    temp.data = data;
                    return true;
                }
                temp = temp.next;
            }
        } else if (oldData instanceof Number) {
            while (temp.next != null) {
                if (temp.data == oldData) {
                    foundNum++;
                    temp.data = data;
                    return true;
                }
                temp = temp.next;
            }
        }
        if (foundNum == 0)
            return false;
        return true;

    }
}
</code></pre>
<p>测试java文件：</p>
<pre><code class="language-java">public class TestLink {
    public static void main(String[] args) {
        MyLinkNode&lt;String&gt; myLinkNode = new MyLinkNode&lt;&gt;();
        myLinkNode.add(&quot;1&quot;);
        myLinkNode.add(&quot;2&quot;);
        myLinkNode.add(&quot;3&quot;);
        myLinkNode.add(&quot;4&quot;);
        myLinkNode.insert(3,&quot;insert&quot;);
        myLinkNode.printNode();
        System.out.println(&quot;length=&quot;+myLinkNode.length());
        System.out.println(&quot;\n&quot;);
        myLinkNode.delete(&quot;insert&quot;);
        myLinkNode.printNode();
        System.out.println(&quot;length=&quot;+myLinkNode.length());

    }
}
</code></pre>
<h4>单链表的实现</h4>
<pre><code class="language-java">package com.zjn.LinkAndQueue;

/**
 * 自定义链表设计
 * 
 * @author zjn
 *
 */
public class MyLink {
    Node head = null; // 头节点

    /**
     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用
     * 
     * @author zjn
     *
     */
    class Node {
        Node next = null;// 节点的引用，指向下一个节点
        int data;// 节点的对象，即内容

        public Node(int data) {
            this.data = data;
        }
    }

    /**
     * 向链表中插入数据
     * 
     * @param d
     */
    public void addNode(int d) {
        Node newNode = new Node(d);// 实例化一个节点
        if (head == null) {
            head = newNode;
            return;
        }
        Node tmp = head;
        while (tmp.next != null) {
            tmp = tmp.next;
        }
        tmp.next = newNode;
    }

    /**
     * 
     * @param index:删除第index个节点
     * @return
     */
    public boolean deleteNode(int index) {
        if (index &lt; 1 || index &gt; length()) {
            return false;
        }
        if (index == 1) {
            head = head.next;
            return true;
        }
        int i = 1;
        Node preNode = head;
        Node curNode = preNode.next;
        while (curNode != null) {
            if (i == index) {
                preNode.next = curNode.next;
                return true;
            }
            preNode = curNode;
            curNode = curNode.next;
            i++;
        }
        return false;
    }

    /**
     * 
     * @return 返回节点长度
     */
    public int length() {
        int length = 0;
        Node tmp = head;
        while (tmp != null) {
            length++;
            tmp = tmp.next;
        }
        return length;
    }

    /**
     * 在不知道头指针的情况下删除指定节点
     * 
     * @param n
     * @return
     */
    public boolean deleteNode11(Node n) {
        if (n == null || n.next == null)
            return false;
        int tmp = n.data;
        n.data = n.next.data;
        n.next.data = tmp;
        n.next = n.next.next;
        System.out.println(&quot;删除成功！&quot;);
        return true;
    }

    public void printList() {
        Node tmp = head;
        while (tmp != null) {
            System.out.println(tmp.data);
            tmp = tmp.next;
        }
    }

    public static void main(String[] args) {
        MyLink list = new MyLink();
        list.addNode(5);
        list.addNode(3);
        list.addNode(1);
        list.addNode(2);
        list.addNode(55);
        list.addNode(36);
        System.out.println(&quot;linkLength:&quot; + list.length());
        System.out.println(&quot;head.data:&quot; + list.head.data);
        list.printList();
        list.deleteNode(4);
        System.out.println(&quot;After deleteNode(4):&quot;);
        list.printList();
    }
}
</code></pre>
<h4>经典问题</h4>
<h5>反转链表</h5>
<p>data域：存储数据元素信息的域称为数据域；</p>
<p>next域：存储直接后继位置的域称为指针域，它是存放结点的直接后继的地址（位置）的指针域（链域）。</p>
<p>data域+ next域：组成数据ai的存储映射，称为结点；</p>
<p>创建一结点类，其Java代码如下：</p>
<pre><code class="language-java">class Node {
    private int Data;// 数据域
    private Node Next;// 指针域
    public Node(int Data) {
        // super();
        this.Data = Data;
    }
    public int getData() {
        return Data;
    }
    public void setData(int Data) {
        this.Data = Data;
    }

    public Node getNext() {
        return Next;
    }
    public void setNext(Node Next) {
        this.Next = Next;
    }
}
</code></pre>
<h4>反转的方法-递归反转法</h4>
<pre><code class="language-java">    /**
     * 递归，在反转当前节点之前先反转后续节点
     */
    public static Node recursiveReverse(Node currentNode) {
        if (currentNode == null || currentNode.getNext() == null) {
            return currentNode;
        }

        Node returnNode = recursiveReverse(currentNode.getNext());
        //这里是重点。
        //当前节点（currentNode）的下一个节点，正好是返回节点returnNode的最后一个节点
        currentNode.getNext().setNext(currentNode);
        currentNode.setNext(null);
        return returnNode;
    }
</code></pre>
<h4>反转的方法-遍历反转法</h4>
<pre><code class="language-java">    //思路：
    //当前节点的next不为null，则需要进行反转
    //反转即：需要将next的next设置为当前节点

    public static Node cycleReverse(Node currentNode) {

        if (currentNode == null) {
            return currentNode;
        }

        //专门记录下一个节点（依次判断下个节点是否为空）
        Node nextNode = currentNode.getNext();

        //记录next的next用于下次循环使用
        Node temp;

        //准备好第一个节点（第一个节点不需要去反转）
        currentNode.setNext(null);
        Node finalNode = currentNode;//最终返回的链表

        //如果下一个几点不为空，说明还有节点，则进行反转
        while (nextNode != null) {
            //记录元素，为了指针下移
            temp = nextNode.getNext();

            //反转链表
            nextNode.setNext(finalNode);
            finalNode = nextNode;

            //指针下移
            nextNode = temp;
        }

        return finalNode;
    }
</code></pre>
<h4>奇偶链表</h4>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<pre><code class="language-java">    public static ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;


        while (odd.next != null &amp;&amp; even.next != null) {
            odd.next = even.next;
            odd = odd.next;

            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
</code></pre>
<h4>回文链表</h4>
<pre><code class="language-java">    /**
     * 断一个链表是否为回文链表
     * 输入: 1-&gt;2-&gt;2-&gt;1
     * 输出: true
     */
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        ListNode reverseNode = null;//指向反转的链表
        ListNode nomalNode;//指向后面后半截链表

        if (head.next.next == null) {
            reverseNode = head;
            nomalNode = head.next;
            reverseNode.next = null;
        } else {
            //快慢指针找中间值
            //顺便反转前半截链表
            ListNode slow = head;
            ListNode fast = head;

            ListNode tempSlow;
            ListNode tempFast;


            while (fast.next != null &amp;&amp; fast.next.next != null) {
                tempSlow = slow.next;
                tempFast = fast.next.next;

                slow.next = reverseNode;
                reverseNode = slow;

                slow = tempSlow;
                fast = tempFast;
            }


            tempSlow = slow.next;
            slow.next = reverseNode;
            reverseNode = slow;


            //考虑链表是奇数长度链表
            if (fast.next == null) {
                reverseNode = reverseNode.next;
            }

            nomalNode = tempSlow;
        }

        //遍历后半截找不同
        while (nomalNode != null &amp;&amp; reverseNode != null) {
            if (nomalNode.val != reverseNode.val) {
                return false;
            }
            nomalNode = nomalNode.next;
            reverseNode = reverseNode.next;
        }

        return true;
</code></pre>
<h5>查找单链表的中间节点</h5>
<p>采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点。</p>
<pre><code class="language-java">/**
     * 查找单链表的中间节点
     * 
     * @param head
     * @return
     */
    public Node SearchMid(Node head) {
        Node p = this.head, q = this.head;
        while (p != null &amp;&amp; p.next != null &amp;&amp; p.next.next != null) {
            p = p.next.next;
            q = q.next;
        }
        System.out.println(&quot;Mid:&quot; + q.data);
        return q;
    }
</code></pre>
<h5>查找倒数第k个元素</h5>
<p>采用两个指针P1,P2，P1先前移K步，然后P1、P2同时移动，当p1移动到尾部时，P2所指位置的元素即倒数第k个元素 。</p>
<pre><code class="language-java">/**
     * 查找倒数 第k个元素
     * 
     * @param head
     * @param k
     * @return
     */
    public Node findElem(Node head, int k) {
        if (k &lt; 1 || k &gt; this.length()) {
            return null;
        }
        Node p1 = head;
        Node p2 = head;
        for (int i = 0; i &lt; k; i++)// 前移k步
            p1 = p1.next;
        while (p1 != null) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p2;
    }
</code></pre>
<h5>对链表进行排序</h5>
<pre><code class="language-java">/**
     * 排序
     * 
     * @return
     */
    public Node orderList() {
        Node nextNode = null;
        int tmp = 0;
        Node curNode = head;
        while (curNode.next != null) {
            nextNode = curNode.next;
            while (nextNode != null) {
                if (curNode.data &gt; nextNode.data) {
                    tmp = curNode.data;
                    curNode.data = nextNode.data;
                    nextNode.data = tmp;
                }
                nextNode = nextNode.next;
            }
            curNode = curNode.next;
        }
        return head;
    }
</code></pre>
<h5>删除链表中的重复节点</h5>
<pre><code class="language-java">/**
     * 删除重复节点
     */
    public void deleteDuplecate(Node head) {
        Node p = head;
        while (p != null) {
            Node q = p;
            while (q.next != null) {
                if (p.data == q.next.data) {
                    q.next = q.next.next;
                } else
                    q = q.next;
            }
            p = p.next;
        }

    }
</code></pre>
<h5>判断链表是否有环，有环情况下找出环的入口节点</h5>
<pre><code class="language-java">/**
     * 判断链表是否有环，单向链表有环时，尾节点相同
     * 
     * @param head
     * @return
     */
    public boolean IsLoop(Node head) {
        Node fast = head, slow = head;
        if (fast == null) {
            return false;
        }
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                System.out.println(&quot;该链表有环&quot;);
                return true;
            }
        }
        return !(fast == null || fast.next == null);
    }

    /**
     * 找出链表环的入口
     * 
     * @param head
     * @return
     */
    public Node FindLoopPort(Node head) {
        Node fast = head, slow = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast)
                break;
        }
        if (fast == null || fast.next == null)
            return null;
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
</code></pre>
<h4>双链表节点结构</h4>
<pre><code class="language-java">// Definition for doubly-linked list.
class DoublyListNode {
    int val;
    DoublyListNode next, prev;
    DoublyListNode(int x) {val = x;}
}
</code></pre>
<h4>合并两个有序链表</h4>
<pre><code class="language-java">   /**
     * 合并两个有序链表
     */
    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        if (l1 == null) {
            return l2;
        }

        if (l2 == null) {
            return l1;
        }

        
        ListNode temp1 = l1;
        ListNode temp2 = l2;
        ListNode mergeListNode;
        if (l1.val &gt; l2.val) {
            mergeListNode = l2;
            temp2 = l2.next;
        } else {
            mergeListNode = l1;
            temp1 = l1.next;
        }
        ListNode mergeListNodePointer = mergeListNode;


        //每次循环只前进一个指针
        while (temp1 != null &amp;&amp; temp2 != null) {
            if (temp1.val &gt; temp2.val) {
                mergeListNodePointer.next = temp2;
                mergeListNodePointer=mergeListNodePointer.next;
                temp2 = temp2.next;
            } else {
                mergeListNodePointer.next = temp1;
                mergeListNodePointer=mergeListNodePointer.next;
                temp1 = temp1.next;
            }
        }

        //将剩余的节点拼接起来
        if (temp1 != null) {
            mergeListNodePointer.next = temp1;
        }

        if (temp2 != null) {
            mergeListNodePointer.next = temp2;
        }

        return mergeListNode;
    }
</code></pre>
<h4>java链表两数相加</h4>
<h5>位数按照逆序方式存储</h5>
<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br>
示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
<pre><code class="language-java">class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
 
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode  listNode= new ListNode(0);
        ListNode p = new ListNode(0);
        p = listNode;
        int sum = 0;
 
        while (l1 != null || l2 != null || sum != 0) {
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }
            p.next = new ListNode(sum % 10);
            sum = sum / 10;
            p = p.next;
        }
        return listNode.next;
    }
}
</code></pre>
<h5>位数按照正序方式存储</h5>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br>
你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br>
示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<pre><code class="language-java">  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;();
    Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;();

    while(l1!=null){
        stack1.push(l1.val);
        l1=l1.next;
    }
    while(l2!=null){
        stack2.push(l2.val);
        l2=l2.next;
    }


    ListNode temp=null;
    int isCarry=0;
    while(!stack1.isEmpty()||!stack2.isEmpty()||isCarry&gt;0){
        int sum=(stack1.isEmpty()?0:stack1.pop())+
        (stack2.isEmpty()?0:stack2.pop())+isCarry;
     ListNode n=new ListNode(sum%10);
    isCarry=sum/10;
       n.next=temp;
       temp=n;
    }
        return temp;
    }
</code></pre>
<h5>常用方法：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public boolean add(E e)</td>
<td style="text-align:left">链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public void add(int index, E element)</td>
<td style="text-align:left">向指定位置插入元素。</td>
</tr>
<tr>
<td style="text-align:left">public boolean addAll(Collection c)</td>
<td style="text-align:left">将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public boolean addAll(int index, Collection c)</td>
<td style="text-align:left">将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public void addFirst(E e)</td>
<td style="text-align:left">元素添加到头部。</td>
</tr>
<tr>
<td style="text-align:left">public void addLast(E e)</td>
<td style="text-align:left">元素添加到尾部。</td>
</tr>
<tr>
<td style="text-align:left">public boolean offer(E e)</td>
<td style="text-align:left">向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public boolean offerFirst(E e)</td>
<td style="text-align:left">头部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public boolean offerLast(E e)</td>
<td style="text-align:left">尾部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public void clear()</td>
<td style="text-align:left">清空链表。</td>
</tr>
<tr>
<td style="text-align:left">public E removeFirst()</td>
<td style="text-align:left">删除并返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public E removeLast()</td>
<td style="text-align:left">删除并返回最后一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public boolean remove(Object o)</td>
<td style="text-align:left">删除某一元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td style="text-align:left">public E remove(int index)</td>
<td style="text-align:left">删除指定位置的元素。</td>
</tr>
<tr>
<td style="text-align:left">public E poll()</td>
<td style="text-align:left">删除并返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public E remove()</td>
<td style="text-align:left">删除并返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public boolean contains(Object o)</td>
<td style="text-align:left">判断是否含有某一元素。</td>
</tr>
<tr>
<td style="text-align:left">public E get(int index)</td>
<td style="text-align:left">返回指定位置的元素。</td>
</tr>
<tr>
<td style="text-align:left">public E getFirst()</td>
<td style="text-align:left">返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public E getLast()</td>
<td style="text-align:left">返回最后一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public int indexOf(Object o)</td>
<td style="text-align:left">查找指定元素从前往后第一次出现的索引。</td>
</tr>
<tr>
<td style="text-align:left">public int lastIndexOf(Object o)</td>
<td style="text-align:left">查找指定元素最后一次出现的索引。</td>
</tr>
<tr>
<td style="text-align:left">public E peek()</td>
<td style="text-align:left">返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public E element()</td>
<td style="text-align:left">返回第一个元素。</td>
</tr>
<tr>
<td style="text-align:left">public E peekFirst()</td>
<td style="text-align:left">返回头部元素。</td>
</tr>
<tr>
<td style="text-align:left">public E peekLast()</td>
<td style="text-align:left">返回尾部元素。</td>
</tr>
<tr>
<td style="text-align:left">public E set(int index, E element)</td>
<td style="text-align:left">设置指定位置的元素。</td>
</tr>
<tr>
<td style="text-align:left">public Object clone()</td>
<td style="text-align:left">克隆该列表。</td>
</tr>
<tr>
<td style="text-align:left">public Iterator descendingIterator()</td>
<td style="text-align:left">返回倒序迭代器。</td>
</tr>
<tr>
<td style="text-align:left">public int size()</td>
<td style="text-align:left">返回链表元素个数。</td>
</tr>
<tr>
<td style="text-align:left">public ListIterator listIterator(int index)</td>
<td style="text-align:left">返回从指定位置开始到末尾的迭代器。</td>
</tr>
<tr>
<td style="text-align:left">public Object[] toArray()</td>
<td style="text-align:left">返回一个由链表元素组成的数组。</td>
</tr>
<tr>
<td style="text-align:left">public T[] toArray(T[] a)</td>
<td style="text-align:left">返回一个由链表元素转换类型而成的数组。</td>
</tr>
</tbody>
</table>
<h3>三、应用场景</h3>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</p>
<h3>四、空间和时间复杂度</h3>
<p>由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p>这里我们提供链表和其他数据结构（包括数组，队列和栈）之间时间复杂度的比较：</p>
<figure data-type="image" tabindex="4"><img src="https://clownjerome.github.io/post-images/1635516586310.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashCode详解]]></title>
        <id>https://clownjerome.github.io/post/hashcode-xiang-jie/</id>
        <link href="https://clownjerome.github.io/post/hashcode-xiang-jie/">
        </link>
        <updated>2021-10-12T01:50:05.000Z</updated>
        <content type="html"><![CDATA[<h3>一、hashcode是什么？</h3>
<p>1、hash和hash表是什么？</p>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值，这个时候，我们就需要知道另一个东西，<a href="#hat">hash</a>表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值。</p>
<p>2、hashcode</p>
<p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。</p>
<p>每个对象都有hashcode，对象的hashcode怎么得来的呢？</p>
<p>首先一个对象肯定有物理地址，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode，所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(...)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p>
<h3>二、hashcode有什么作用呢？</h3>
<p>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的。</p>
<h3>三、equals方法和hashcode的关系？</h3>
<p>先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p>
<p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同。</p>
<p>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。</p>
<h3 id="hat">hash表</h3>
<p>哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。</p>
<p>哈希表也有自己的缺点，哈希表是基于数组的，我们知道数组创建后扩容成本比较高，所以当哈希表被填满时，性能下降的比较严重。</p>
<p>哈希表采用的是一种转换思想，其中一个中要的概念是如何将**「键」<strong>或者</strong>「关键字」<strong>转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个</strong>「键」<strong>或者</strong>「关键字」<strong>都需要通过哈希函数来将其转换成数组下标，有些</strong>「键」<strong>或者</strong>「关键字」**可以直接作为数组的下标。</p>
<p>hash函数</p>
<p>哈希函数的作用是帮我们把非int的**「键」<strong>或者</strong>「关键字」**转化成int，可以用来做数组的下标。</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1634003504347.png" alt="" loading="lazy"></figure>
<p>哈希函数的写法有很多种，我们来看看**「HashMap」**中的哈希函数</p>
<pre><code class="language-java">    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>
<p>**「HashMap」<strong>中利用了</strong>「hashCode」**来完成这个转换。哈希函数不管怎么实现，都应该满足下面三个基本条件：</p>
<ul>
<li>散列函数计算得到的散列值是一个非负整数</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li>
</ul>
<p>第一点：因为数组的下标是从0开始，所以哈希函数生成的哈希值也应该是非负数</p>
<p>第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据</p>
<p>第三点：两个不一样的值通过哈希函数之后可能产生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突</p>
<p>hash冲突</p>
<p>哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种**「开放地址法」<strong>和</strong>「链表法」**</p>
<p>开放地址法</p>
<p>在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是**「线性探测」<strong>、</strong>「二次探测」<strong>、</strong>「再哈希法」**</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 中 String 与 StringBuffer 和 StringBuilder 的区别]]></title>
        <id>https://clownjerome.github.io/post/java-zhong-string-yu-stringbuffer-he-stringbuilder-de-qu-bie/</id>
        <link href="https://clownjerome.github.io/post/java-zhong-string-yu-stringbuffer-he-stringbuilder-de-qu-bie/">
        </link>
        <updated>2021-10-12T01:47:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>String 是 Java 中很常用的类之一，同时，字符串是 Java 面试中最重要的话题之一。</p>
<p>StringBuffer 和 StringBuilder 类提供了操作字符串的方法。</p>
<p>我们将研究 StringBuffer 和 StringBuilder 之间的区别。</p>
<p>StringBuffer 与 StringBuilder 的区别是 Java 中很常见的面试题。</p>
<p>在控制台上打印程序的内容，可以使用 String。此博客介绍 String 类的主要功能，然后我们将比较 StringBuffer 和 StringBuilder 类。</p>
<h2 id="string">String</h2>
<p>注意一个常见的错误，不要记错了。因为 String 是 final 修饰的，无法被继承。所以 String 不是 Java 的基本数据类型。<br>
字符串在 Java 中是不可变的，因此适合在多线程环境下使用。<br>
当我们使用双引号创建一个字符串时，如下，JVM 首先在字符串池中寻找具有相同值的字符串。</p>
<pre><code class="language-java">String str1 = &quot;ABC&quot;;
</code></pre>
<p>如果找到了，它将返回字符串池中的字符串对象的引用。否则，它会在字符串池中创建字符串对象并返回引用。JVM 通过在不同的线程中使用相同的字符串，节省了大量的内存。</p>
<p>如果使用 new 运算符创建字符串，则会在堆中创建它。</p>
<p>运算符 <code>+</code> 是为 String 重载的，我们可以用它来串联两个字符串。尽管在内部它使用 StringBuilder 来执行这个动作。</p>
<p>两个字符串只有在它们具有相同字符串的时候才相等，equals() 方法区分大小写。如果您正在寻找不区分大小写的检查，您应该使用 equalsIgnoreCase() 方法。</p>
<h2 id="拼接字符串">拼接字符串</h2>
<p>由于 String 在 Java 中是不可变的，因此每当我们执行字符串拼接操作时，它都会生成一个新的 String 并丢弃旧的 String 以进行垃圾收集。<br>
这些重复的操作会在堆中产生大量垃圾冗余。所以 Java 提供了 StringBuffer 和 StringBuilder 类，应该用于字符串操作。<br>
StringBuffer 和 StringBuilder 是 Java 中的可变对象。</p>
<p>它们为字符串操作提供了 <code>append</code>、<code>insert</code>、<code>delete</code> 和 <code>substring</code> 方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">StringBuffer</th>
<th style="text-align:left">StringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">线程安全</td>
<td style="text-align:left">非线程安全</td>
</tr>
<tr>
<td style="text-align:left">同步</td>
<td style="text-align:left">非同步</td>
</tr>
<tr>
<td style="text-align:left">始于 Java 1.0</td>
<td style="text-align:left">始于 Java 1.5</td>
</tr>
<tr>
<td style="text-align:left">慢</td>
<td style="text-align:left">快</td>
</tr>
</tbody>
</table>
<p>在 Java 1.4 之前，StringBuffer 是字符串操作的唯一选择。但是，它的一个缺点是所有公共方法都是同步的。 StringBuffer 提供线程安全性，但以性能为代价。</p>
<p>在大多数情况下，我们不会在多线程环境中使用 String。所以 Java 1.5 引入了一个新类 StringBuilder，除了线程安全和同步之外，它与 StringBuffer 类似。</p>
<p>StringBuffer 有一些额外的方法，例如 substring, length, capacity, trimToSize 等。但是，这些不是必需的，因为 String 中也有所有这些。这就是为什么这些方法从未在 StringBuilder 类中实现的原因。</p>
<p>StringBuffer 是在 Java 1.0 中引入的，而 StringBuilder 类是在查看 StringBuffer 的缺点后在 Java 1.5 中引入的。</p>
<p>假设在单线程环境中或无关线程安全，要使用 StringBuilder。反之，使用 StringBuffer 进行线程安全的操作。</p>
<h2 id="总结">总结</h2>
<ul>
<li>String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。</li>
<li>StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。</li>
<li>字符串连接运算符 (+) 在内部使用 StringBuilder 类。</li>
<li>对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么 HashMap 常用 String 对象作 key]]></title>
        <id>https://clownjerome.github.io/post/wei-shi-me-hashmap-chang-yong-string-dui-xiang-zuo-key/</id>
        <link href="https://clownjerome.github.io/post/wei-shi-me-hashmap-chang-yong-string-dui-xiang-zuo-key/">
        </link>
        <updated>2021-10-11T01:06:14.000Z</updated>
        <content type="html"><![CDATA[<p>设计 hashCode() 时最重要的因素就是对同一个对象调用 hashCode() 都应该产生相同的值。String 类型的对象对这个条件有着很好的支持，因为 String 对象的 hashCode() 值是根据 String 对象的内容计算的，并不是根据对象的地址计算。</p>
<p>即使是Test重写了hashCode和equals 方法，也不如String高效，最关键的是String中缓存有个hash变量，它可以缓存hashCode，避免重复计算hashCode。例如，你有一个 student1对象作为map的key值，你第二次使用student1作为key值放入map中时，会再次student1的hashCode。</p>
<p>下面是 String 类源码中的 hashCode() 方法：String 对象底层是一个 final 修饰的 char 类型的数组，hashCode() 的计算是根据字符数组的每个元素进行计算的，所以内容相同的 String 对象会产生相同的散列码。</p>
<pre><code class="language-java">/**
     * Returns a hash code for this string. The hash code for a
     * {@code String} object is computed as
     * &lt;blockquote&gt;&lt;pre&gt;
     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * using {@code int} arithmetic, where {@code s[i]} is the
     * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of
     * the string, and {@code ^} indicates exponentiation.
     * (The hash value of the empty string is zero.)
     *
     * @return  a hash code value for this object.
     */
public int hashCode() {
        int h = hash;     //private int hash; // Default to 0
        if (h == 0 &amp;&amp; value.length &gt; 0) {
            char val[] = value;    //获得 String 对象底层的字符数组

            for (int i = 0; i &lt; value.length; i++) {
                h = 31 * h + val[i];    //在计算的时候加的是 int 类型的 ascii 码
            }
            hash = h;
        }
        return h;
    }
</code></pre>
<p>我们希望的是我们在用对象作为 key 时，我们在获取的时候也依然能够根据重新定义 key 获得对应的 value。就像下面这样，但是它却不能正常工作：这两个对象产生的散列码是不同的，所以在进行 equals() 判断的时候这两个对象被认定为是不同的对象，自然也就获取不到对应的 value。</p>
<p>如果你想获得 map 中存储的“123”，那么你只有把 test 对象作为 key 才能获取到，我们试图用一种简单的方法就能让它工作，但是这显然与我们的初衷相背驰。所以非 String 类型的数据类型在判断 key 相同时所需要的条件太过苛刻。</p>
<pre><code class="language-java">Test test = new Test();
Map&lt;Test,String&gt; map1 = new HashMap&lt;&gt;();
map1.put(test,&quot;123&quot;);

System.out.print(map1.get(new Test()));    //我们试图取出对应的 value

/**
* 输出
* null
*/
</code></pre>
<p>但是 String 类型的对象就不一样了，内容相同的两个 String 对象具有相同的散列码，并且经过 equals() 判断后返回值为 true，所以在进行查找的时候它可以正常工作。</p>
<pre><code class="language-java">String key = &quot;key&quot;;
HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
map.put(key,123);

System.out.println(map.get(&quot;key&quot;));

/**
* 输出
* 123
*/
</code></pre>
<p>总结：在使用 String 类型的对象做 key 时我们可以只根据传入的字符串内容就能获得对应存在 map 中的 value 值，而非 String 类型的对象在获得对应的 value 时需要的条件太过苛刻，首先要保证散列码相同，并且经过 equals() 方法判断为 true 时才可以获得对应的 value。</p>
<p>PS：<br>
如果你想把自定义的对象作为 key，那也是可以的，你只需要重写 hashCode() 方法与 equals() 方法即可，按照你自己的意愿定义散列码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习进程]]></title>
        <id>https://clownjerome.github.io/post/xue-xi-jin-cheng/</id>
        <link href="https://clownjerome.github.io/post/xue-xi-jin-cheng/">
        </link>
        <updated>2021-10-10T12:47:05.000Z</updated>
        <content type="html"><![CDATA[<p>https://cyc2018.xyz/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础]]></title>
        <id>https://clownjerome.github.io/post/java-ji-chu/</id>
        <link href="https://clownjerome.github.io/post/java-ji-chu/">
        </link>
        <updated>2021-10-10T12:36:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#datatype" id="back">一、数据类型</a></p>
<p>    <a href="#bt">基本类型</a></p>
<p>    <a href="#pt">包装类型</a></p>
<p>    <a href="#bpt">缓存池</a></p>
<p><a href="#st">二、String</a></p>
<p>    <a href="#stov">概览</a></p>
<p>    <a href="#nv">不可变的好处</a></p>
<p>    <a href="#sss">String，StringBuffer and StringBuilder</a></p>
<p>    <a href="#sp">String Pool</a></p>
<p>    <a href="#ns">new S tring（“abc”）</a></p>
<p><a href="#operation">三、运算</a></p>
<p>     <a href="#pp">参数传递</a></p>
<p>     <a href="#fd">float与double</a></p>
<p>     <a href="#ltc">隐式类型转换</a></p>
<p>     <a href="#sw">switch</a></p>
<p><a href="#keyword">四、关键字</a></p>
<p>     <a href="#fi">final</a></p>
<p>     <a href="#st">static</a></p>
<p><a href="#ob">五、Object通用方法</a></p>
<p>     <a href="#obov">概览</a></p>
<p>     <a href="#eq">equals（）</a></p>
<p>     <a href="#hc">hashCode（）</a></p>
<p>     <a href="#ts">toString（）</a></p>
<p>     <a href="#cl">clone</a></p>
<p><a href="#inherit">六、继承</a></p>
<p>     <a href="#aap">访问权限</a></p>
<p>     <a href="#acai">抽象类与接口</a></p>
<p>     <a href="#sup">super</a></p>
<p>     <a href="#rao">重写与重载</a></p>
<p><a href="#ref">七、反射</a></p>
<p><a href="#abn">八、异常</a></p>
<p><a href="#gen">九、泛型</a></p>
<p><a href="#note">十、注解</a></p>
<p><a href="#pec">十一、特性</a></p>
<p>     <a href="#jnpec">Java各版本的新特性</a></p>
<p>     <a href="#jac">Java与C++的区别</a></p>
<p>     <a href="#joj">JRE or JDK</a></p>
<h2 id="datatype">一、数据类型</h2>
<p>     <h3 id="bt">基本类型</h3></p>
<ul>
<li>
<p>byte/8</p>
</li>
<li>
<p>char/16</p>
</li>
<li>
<p>short/16</p>
</li>
<li>
<p>int/32</p>
</li>
<li>
<p>float/32</p>
</li>
<li>
<p>long/64</p>
</li>
<li>
<p>double/64</p>
</li>
<li>
<p>boolean/~</p>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。<a href="#jj" id="bjj">JVM</a> 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
</li>
</ul>
<p>参考文件：</p>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></p>
<p>     <h3 id="pt">包装类型</h3></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
</code></pre>
<p>Java1.5以下因为不能直接地向集合(Collections)中放入原始类型值，集合只接收对象。通常这种情况下的做法，是将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用Integer,Double,Boolean等这些类我们可以将原始类型值转换成对应的对象。为了让代码简练，Java 1.5引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的bug。</p>
<h3>补充：</h3>
<hr/>
<h3>自动装箱和拆箱</h3>
<p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte,short,char,int,long,float,double和boolean对应的封装类为Byte,Short,Character,Integer,Long,Float,Double,Boolean。</p>
<p>基本类型与封装类型对应关系：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>封装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>自动装箱，相当于Java编译器替我们执行了 <code>Integer.valueOf(XXX);</code></p>
<p>自动拆箱，相当于Java编译器替我们执行了<code>Integer.intValue(XXX);</code></p>
<h3>要点</h3>
<p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。</p>
<p>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作。</p>
<h3>何时发生自动装箱和拆箱</h3>
<p>自动装箱和拆箱在Java中很常见，比如我们有一个方法，接受一个对象类型的参数，如果我们传递一个原始类型值，那么Java会自动将这个原始类型值转换成与之对应的对象。最经典的一个场景就是当我们向<a href="#arr" id="barr">ArrayList</a>这样的容器中增加原始类型数据时或者是创建一个参数化的类，比如下面的<a href="#tl" id="btl">ThreadLocal</a>。</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
intList.add(1); //autoboxing - primitive to object
intList.add(2); //autoboxing

ThreadLocal&lt;Integer&gt; intLocal = new ThreadLocal&lt;Integer&gt;();
intLocal.set(4); //autoboxing

int number = intList.get(0); // unboxing
int local = intLocal.get(); // unboxing in Java
</code></pre>
<p>eg:自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p>
<p>赋值时</p>
<p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p>
<pre><code class="language-text">//before autoboxing
Integer iObject = Integer.valueOf(3);
Int iPrimitive = iObject.intValue()

//after java5
Integer iObject = 3; //autobxing - primitive to wrapper conversion
int iPrimitive = iObject; //unboxing - object to primitive conversion
</code></pre>
<p>方法调用时</p>
<p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p>
<pre><code class="language-text">public static Integer show(Integer iParam){
   System.out.println(&quot;autoboxing example - method invocation i: &quot; + iParam);
   return iParam;
}

//autoboxing and unboxing in method invocation
show(3); //autoboxing
int result = show(3); //unboxing because return type of method is Integer
</code></pre>
<p>show方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而int result = show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</p>
<p><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></p>
<p>     <h3 id="bpt">缓存池</h3></p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
</code></pre>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<pre><code class="language-java">static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k &lt; cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high &gt;= 127;
}
</code></pre>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动jvm的时候，通过 -XX:AutoBoxCacheMax=<code>&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 </a></p>
<p><a href="#back">返回</a></p>
<h2 id="st">二、String</h2>
<p>     <h3 id="stov">概览</h3></p>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
</code></pre>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
</code></pre>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<p>     <h3 id="nv">不可变的好处</h3></p>
<p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 <a href="#ha" id="bha">hash</a> 值经常被使用，例如 <a href="https://clownjerome.github.io/post/wei-shi-me-hashmap-chang-yong-string-dui-xiang-zuo-key/">String 用做 HashMap 的 key</a>。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633869552745.png" alt="" loading="lazy"></figure>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a></p>
<p>     <h3 id="sss">String, StringBuffer and StringBuilder</h3></p>
<p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>
<p>String 不可变，因此是线程安全的</p>
</li>
<li>
<p>StringBuilder 不是线程安全的</p>
</li>
<li>
<p>StringBuffer 是线程安全的，内部使用 <a href="https://www.cnblogs.com/three-fighter/p/14396208.html">synchronized</a> 进行同步</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<p><a href="https://www.runoob.com/java/java-stringbuffer.html">Java StringBuffer 和 StringBuilder 类 | 菜鸟教程 (runoob.com)</a></p>
</li>
</ul>
<p>     <h3 id="sp">String Pool</h3></p>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 &quot;aaa&quot; 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code class="language-java">String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);           // true
</code></pre>
<p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code class="language-java">String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;
System.out.println(s5 == s6);  // true
</code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?(opens new window)</a></li>
<li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li>
</ul>
<p>     <h3 id="ns">new String(&quot;abc&quot;)</h3></p>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<pre><code class="language-java">public class NewStringTest {
    public static void main(String[] args) {
        String s = new String(&quot;abc&quot;);
    }
}
</code></pre>
<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code class="language-java">// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
         9: astore_1
// ...
</code></pre>
<p>在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code class="language-java">public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
</code></pre>
<p><a href="#back">返回</a></p>
<h2 id="operation">运算</h2>
<p>     <h3 id="pp">参数传递</h3></p>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<pre><code class="language-java">public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
</code></pre>
<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<pre><code class="language-java">class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}
</code></pre>
<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<pre><code class="language-java">public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
</code></pre>
<p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<p>     <h3 id="fd">float 与 double</h3></p>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<pre><code class="language-java">// float f = 1.1;
</code></pre>
<p>1.1f 字面量才是 float 类型。</p>
<pre><code class="language-java">float f = 1.1f;
</code></pre>
<p>     <h3 id="ltc">隐式类型转换</h3></p>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<pre><code class="language-java">short s1 = 1;
// s1 = s1 + 1;
</code></pre>
<p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<pre><code class="language-java">s1 += 1;
s1++;
</code></pre>
<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre><code class="language-java">s1 = (short) (s1 + 1);
</code></pre>
<p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?</a></p>
<p>     <h3 id="sw">switch</h3></p>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<pre><code class="language-java">String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}
</code></pre>
<p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<pre><code class="language-java">// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
</code></pre>
<p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can't your switch statement data type be long, Java?</a></p>
<h2 id="keyword">关键字</h2>
<p>     <h3 id="fi">final</h3></p>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<pre><code class="language-java">final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
</code></pre>
<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<p>     <h3 id="st">static</h3></p>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<pre><code class="language-java">public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
</code></pre>
<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<pre><code class="language-java">public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}
</code></pre>
<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p>
<pre><code class="language-java">public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
</code></pre>
<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<pre><code class="language-java">public class A {
    static {
        System.out.println(&quot;123&quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
123
</code></pre>
<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<pre><code class="language-java">public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<pre><code class="language-java">import static com.xxx.ClassName.*
</code></pre>
<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<pre><code class="language-java">public static String staticField = &quot;静态变量&quot;;
static {
    System.out.println(&quot;静态语句块&quot;);
}
public String field = &quot;实例变量&quot;;
{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre>
<p>最后才是构造函数的初始化。</p>
<pre><code class="language-java">public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}
</code></pre>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>
<p>父类（静态变量、静态语句块）</p>
</li>
<li>
<p>子类（静态变量、静态语句块）</p>
</li>
<li>
<p>父类（实例变量、普通语句块）</p>
</li>
<li>
<p>父类（构造函数）</p>
</li>
<li>
<p>子类（实例变量、普通语句块）</p>
</li>
<li>
<p>子类（构造函数）</p>
<p><a href="#back">返回</a></p>
</li>
</ul>
<h2 id="ob">Object 通用方法</h2>
<p>     <h3 id="obov">概览</h3></p>
<pre><code class="language-java">public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>
<p>     <h3 id="eq">equals()</h3></p>
<p><strong>1. 等价关系</strong></p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<pre><code class="language-java">x.equals(x); // true
</code></pre>
<p>Ⅱ 对称性</p>
<pre><code class="language-java">x.equals(y) == y.equals(x); // true
</code></pre>
<p>Ⅲ 传递性</p>
<pre><code class="language-java">if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
</code></pre>
<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<pre><code class="language-java">x.equals(y) == x.equals(y); // true
</code></pre>
<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<pre><code class="language-java">x.equals(null); // false;
</code></pre>
<p><strong>2. 等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<pre><code class="language-java">Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
</code></pre>
<p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<pre><code class="language-java">public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
</code></pre>
<p>     <h3 id="hc">hashCode()</h3></p>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
</code></pre>
<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<pre><code class="language-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>
<p>     <h3 id="ts">toString()</h3></p>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<pre><code class="language-java">public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
ToStringExample@4554617c
</code></pre>
<p>     <h3 id="cl">clone()</h3></p>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;
}
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
</code></pre>
<p>重写 clone() 得到以下实现：</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
java.lang.CloneNotSupportedException: CloneExample
</code></pre>
<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<pre><code class="language-java">public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<pre><code class="language-java">public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
</code></pre>
<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<pre><code class="language-java">public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>
<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<pre><code class="language-java">public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>
<p><a href="#back">返回</a></p>
<h2 id="inherit">继承</h2>
<p>     <h3 id="aap">访问权限</h3></p>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<pre><code class="language-java">public class AccessExample {
    public String id;
}
</code></pre>
<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<pre><code class="language-java">public class AccessExample {

    private int id;

    public String getId() {
        return id + &quot;&quot;;
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
</code></pre>
<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<pre><code class="language-java">public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
</code></pre>
<p>     <h3 id="acai">抽象类与接口</h3></p>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<pre><code class="language-java">public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println(&quot;func2&quot;);
    }
}
public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
</code></pre>
<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<pre><code class="language-java">public interface InterfaceExample {

    void func1();

    default void func2(){
        System.out.println(&quot;func2&quot;);
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}
// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
</code></pre>
<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">Abstract Methods and Classes(opens new window)</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface(opens new window)</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface(opens new window)</a></li>
<li><a href="https://www.journaldev.com/12850/java-9-private-methods-interfaces">Java 9 Private Methods in Interfaces</a></li>
</ul>
<p>     <h3 id="sup">super</h3></p>
<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<pre><code class="language-java">public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println(&quot;SuperExample.func()&quot;);
    }
}
public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println(&quot;SuperExtendExample.func()&quot;);
    }
}
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
SuperExample.func()
SuperExtendExample.func()
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super</a></p>
<p>     <h3 id="rao">重写与重载</h3></p>
<p><strong>1. 重写（Override）</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<pre><code class="language-java">class SuperClass {
    protected List&lt;Integer&gt; func() throws Throwable {
        return new ArrayList&lt;&gt;();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList&lt;Integer&gt; func() throws Exception {
        return new ArrayList&lt;&gt;();
    }
}
</code></pre>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<pre><code class="language-java">/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println(&quot;A.show(A)&quot;);
    }

    public void show(C obj) {
        System.out.println(&quot;A.show(C)&quot;);
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println(&quot;B.show(A)&quot;);
    }
}

class C extends B {
}

class D extends C {
}
public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
</code></pre>
<p><strong>2. 重载（Overload）</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<pre><code class="language-java">class OverloadingExample {
    public void show(int x) {
        System.out.println(x);
    }

    public void show(int x, String y) {
        System.out.println(x + &quot; &quot; + y);
    }
}
public static void main(String[] args) {
    OverloadingExample example = new OverloadingExample();
    example.show(1);
    example.show(1, &quot;2&quot;);
}
</code></pre>
<p><a href="#back">返回</a></p>
<h2 id="ref">反射</h2>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li>
<p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li>
<p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li>
<p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API(opens new window)</a></p>
</li>
<li>
<p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p>
<p><a href="#back">返回</a></p>
</li>
</ul>
<h2 id="abn">异常</h2>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://clownjerome.github.io/post-images/1633869472566.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><a href="https://www.journaldev.com/2167/java-exception-interview-questions-and-answersl">Java Exception Interview Questions and Answers(opens new window)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/Qian123/p/5715402.html">Java提高篇——Java 异常处理</a></p>
<p><a href="#back">返回</a></p>
</li>
</ul>
<h2 id="gen">泛型</h2>
<pre><code class="language-java">public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
</code></pre>
<ul>
<li>
<p><a href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html">Java 泛型详解(opens new window)</a></p>
</li>
<li>
<p><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></p>
<p><a href="#back">返回</a></p>
</li>
</ul>
<h2 id="note">注解</h2>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>
<p><a href="#back">返回</a></p>
<h2 id="pec">特性</h2>
<p>     <h3 id="jnpec">Java 各版本的新特性</h3></p>
<p><strong>New highlights in Java SE 8</strong></p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong></p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?(opens new window)</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>
<p>     <h3 id="jac">Java 与 C++ 的区别</h3></p>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?</a></p>
<p>     <h3 id="joj">JRE or JDK</h3></p>
<ul>
<li>
<p>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</p>
</li>
<li>
<p>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</p>
<p><a href="#back">返回</a></p>
</li>
</ul>
<h2>本章其他知识点注释</h2>
<h2 id="arr">Java ArrayList</h2>
<p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p>
<p>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p>
<figure data-type="image" tabindex="3"><img src="https://clownjerome.github.io/post-images/1633869501594.png" alt="" loading="lazy"></figure>
<p>ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p>
<pre><code>import java.util.ArrayList; // 引入 ArrayList 类

ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;();　 // 初始化
</code></pre>
<ul>
<li>E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。</li>
<li>objectName: 对象名。</li>
</ul>
<p><a href="https://www.runoob.com/java/java-arraylist.html">Java ArrayList | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/ArrayList.html">ArrayList (Java SE 11 &amp; JDK 11 ) (runoob.com)</a></p>
<p><a href="#barr">返回</a></p>
<h2 id="tl">ThreadLocal</h2>
<p>在JDK 1.2的版本中ThreadLocal是为解决多线程程序的并发问题；在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<T>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>
<p>作用：</p>
<p>通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
<p>应用场景：</p>
<p>在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用synchronized来保证同一时刻只有一个线程对共享变量进行操作。这种情况下可以将类变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。</p>
<p><a href="#btl">返回</a></p>
<h2 id="ha">Hash</h2>
<p>hash（散列、杂凑）函数，是将任意长度的数据映射到有限长度的域上。直观解释起来，就是对一串数据m进行杂糅，输出另一段固定长度的数据h，作为这段数据的特征（指纹）。散列算法最重要的用途在于给证书、文档、密码等高安全系数的内容添加加密保护。这一方面的用途主要是得益于散列算法的不可逆性，这种不可逆性体现在，你不仅不可能根据一段通过散列算法得到的指纹来获得原有的文件，也不可能简单地创造一个文件并让它的指纹与一段目标指纹相一致。散列算法的这种不可逆性维持着很多安全框架的运营。<br>
无论数据块m有多大，其输出值h为固定长度。将m分成固定长度（如128位），依次进行hash运算，然后用不同的方法迭代即可（如前一块的hash值与后一块的hash值进行异或）。如果不够128位怎么办？用0补全或者用1补全随意，算法中约定好就可以了。</p>
<p>抗碰撞能力：对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p>
<p>抗篡改能力：对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</p>
<p>在用到hash进行管理的数据结构中，比如hashmap，hash值（key）存在的目的是加速键值对的查找，key的作用是为了将元素适当地放在各个桶里，对于抗碰撞的要求没有那么高。换句话说，hash出来的key，只要保证value大致均匀的放在不同的桶里就可以了。但整个算法的set性能，直接与hash值产生的速度有关，所以这时候的hash值的产生速度就尤为重要，以JDK中的String.hashCode()方法为例：</p>
<pre><code class="language-java">    public int hashCode() {
        int h = hash;
 //hash default value : 0 
        if (h == 0 &amp;&amp; value.length &gt; 0) {
 //value : char storage
            char val[] = value;

            for (int i = 0; i &lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
</code></pre>
<p>Hash在Java中的应用<br>
1.HashMap的复杂度<br>
HashMap与ArrayList和LinkedList在数据复杂度的区别。下图是他们的性能对比图：</p>
<table>
<thead>
<tr>
<th></th>
<th>获取</th>
<th>查找</th>
<th>添加/删除</th>
<th>空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td>LinkedList</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(1)</td>
<td>O(N)</td>
</tr>
<tr>
<td>HashMap</td>
<td>O(N/Bucket_size)</td>
<td>O(N/Bucket_size)</td>
<td>O(N/Bucket_size)</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
<p>HashMap整体上性能都非常不错，但是不稳定，为O(N/Buckets)，N就是以数组中没有发生碰撞的元素，Buckets是因碰撞产生的链表。</p>
<p>注：发生碰撞实际上是非常稀少的，所以N/Bucket_size约等于1</p>
<p>HashMap是对Array与Link的折衷处理，Array与Link可以说是两个速度方向的极端，Array注重于数据的获取，而处理修改（添加/删除）的效率非常低；Link由于是每个对象都保持着下一个对象的指针，查找某个数据需要遍历之前所有的数据，所以效率比较低，而在修改操作中比较快。</p>
<p>2.对key进行Hash计算<br>
在JDK8中，由于使用了红黑树来处理大的链表开销，所以hash这边可以更加省力了，只用计算hashCode并移动到低位就可以了。</p>
<pre><code class="language-java">static final int hash(Object key) {
    int h;
    //计算hashCode，并无符号移动到低位
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>举个例子: 363771819^(363771819 &gt;&gt;&gt; 16)</p>
<p>0001 0101 1010 1110 1011 0111 1010 1011(363771819)<br>
0000 0000 0000 0000 0001 0101 1010 1110(5550) XOR<br>
--------------------------------------- =<br>
0001 0101 1010 1110 1010 0010 0000 0101(363766277)<br>
这样做可以实现了高地位更加均匀地混到一起。</p>
<p>下面给出在Java中几个常用的哈希码(hashCode)的算法。</p>
<p>Object类的hashCode. 返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。</p>
<p>String类的hashCode. 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。</p>
<p>Integer等包装类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100), i1.hashCode的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。</p>
<p>int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同上。</p>
<p>3.获取到数组的index的位置<br>
计算了Hash，我们现在要把它插入数组中了</p>
<pre><code class="language-java">i = (tab.length - 1) &amp; hash；
</code></pre>
<p>通过位运算，确定了当前的位置，因为HashMap数组的大小总是2^n，所以实际的运算就是 (0xfff…ff) &amp; hash ，这里的tab.length-1相当于一个mask，滤掉了大于当前长度位的hash，使每个i都能插入到数组中。</p>
<p>4.生成包装类<br>
这个对象是一个包装类，Node</p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;
        //getter and setter .etc.
}
</code></pre>
<p>5.插入包装类到数组<br>
(1)如果输入当前的位置是空的，就插进去，如图，左为插入前，右为插入后</p>
<pre><code class="language-java">0           0
|           |
1 -&gt; null   1 - &gt; null
|           |
2 -&gt; null   2 - &gt; null
|           | 
..-&gt; null   ..- &gt; null
|           | 
i -&gt; null   i - &gt; new node
|           |
n -&gt; null   n - &gt; null
</code></pre>
<p>(2)如果当前位置已经有了node，且它们发生了碰撞，则新的放到前面，旧的放到后面，这叫做链地址法处理冲突。</p>
<pre><code class="language-java">0           0
|           |
1 -&gt; null   1 - &gt; null
|           |
2 -&gt; null   2 - &gt; null
|           | 
..-&gt; null   ..- &gt; null
|           | 
i -&gt; old    i - &gt; new - &gt; old
|           |
n -&gt; null   n - &gt; null
</code></pre>
<p>我们可以发现，失败的hashCode算法会导致HashMap的性能由数组下降为链表，所以想要避免发生碰撞，就要提高hashCode结果的均匀性。</p>
<p>6.扩容<br>
如果当表中的75%已经被占用，即视为需要扩容了</p>
<pre><code class="language-java">(threshold = capacity * load factor ) &lt; size
</code></pre>
<p>它主要有两个步骤：</p>
<p>容量加倍<br>
左移1位，就是扩大到两倍，用位运算取代了乘法运算</p>
<pre><code class="language-java">newCap = oldCap &lt;&lt; 1;
newThr = oldThr &lt;&lt; 1;
</code></pre>
<p>遍历计算Hash</p>
<pre><code class="language-java">for (int j = 0; j &lt; oldCap; ++j) {
        Node&lt;K,V&gt; e;
        //如果发现当前有Bucket
        if ((e = oldTab[j]) != null) {
            oldTab[j] = null;
            //如果这里没有碰撞
            if (e.next == null)
                //重新计算Hash，分配位置
                newTab[e.hash &amp; (newCap - 1)] = e;
            //这个见下面的新特性介绍，如果是树，就填入树
            else if (e instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
            //如果是链表，就保留顺序....目前就看懂这点
            else { // preserve order
                Node&lt;K,V&gt; loHead = null, loTail = null;
                Node&lt;K,V&gt; hiHead = null, hiTail = null;
                Node&lt;K,V&gt; next;
                do {
                    next = e.next;
                    if ((e.hash &amp; oldCap) == 0) {
                        if (loTail == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                    }
                    else {
                        if (hiTail == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                    newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
</code></pre>
<p><a href="https://www.runoob.com/ruby/ruby-hash.html">Ruby 哈希（Hash） | 菜鸟教程 (runoob.com)</a></p>
<p><a href="#bha">返回</a></p>
<h2 id="jj">JVM</h2>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect">jvm系列(一):java类的加载机制 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483949&amp;idx=1&amp;sn=8b69d833bbc805e63d5b2fa7c73655f5&amp;chksm=ebf6da52dc815344add64af6fb78fee439c8c27b539b3c0e87d8f6861c8422144d516ae0a837&amp;scene=21#wechat_redirect">jvm系列(二):JVM内存结构 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483952&amp;idx=1&amp;sn=ea12792a9b7c67baddfaf425d8272d33&amp;chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&amp;scene=21#wechat_redirect">jvm系列(三):GC算法 垃圾收集器 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483966&amp;idx=1&amp;sn=dfa3375d36aa2c0c25a775522e381e62&amp;chksm=ebf6da41dc815357e0d53c73865a23f41219e75bac5a4d510bfa31cc51594b59a20e2e4f6cb8&amp;scene=21#wechat_redirect">jvm系列(四):jvm调优-命令篇 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483986&amp;idx=1&amp;sn=a2d7c9f2e73dfcc938a3ec934b3ad3a4&amp;chksm=ebf6da2ddc81533beb5e6fb54c872b5f79524d0780c484718a57ca0712916cd67bda7dee4073&amp;scene=21#wechat_redirect">jvm系列(五):Java GC 分析 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484023&amp;idx=1&amp;sn=39be119fdf3132240adc84a85bf8a054&amp;chksm=ebf6da08dc81531e3719389555150f2d0237554b6b6c07a123efdea7c78c0ae2f064cc577bd4&amp;scene=21#wechat_redirect">jvm系列(七):jvm调优-工具篇 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484038&amp;idx=1&amp;sn=e083cc8b248461c8916a819119b059c3&amp;chksm=ebf6daf9dc8153ef27ecd857e6cc85372735e84042679c133892d0993074371a46dd2c28b8b3&amp;scene=21#wechat_redirect">jvm系列(八):jvm知识点总览 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484071&amp;idx=1&amp;sn=84604a51fd18b91f73c46507c182540a&amp;chksm=ebf6dad8dc8153cebb029372c0745a3c6570e527e1f95cee2fb9fb33c50d46c64f20722a3d96&amp;scene=21#wechat_redirect">jvm系列(十):教你如何成为Java的OOM Killer (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484074&amp;idx=1&amp;sn=826318867783afaf99f62b38b2f5c268&amp;chksm=ebf6dad5dc8153c32a6ce0201afe310b47135b07c8bb028a8fd9df7ecaf6e60950a7847c7df5&amp;scene=21#wechat_redirect">jvm系列(十一):Java 8-从持久代到metaspace (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483921&amp;idx=1&amp;sn=7bb57b405e808c369159b80b32866a1a&amp;chksm=ebf6da6edc815378b5486ca644de17f32bbdc68cc4430a9d62755cd4bdad6d04dc69f592f51c&amp;scene=21#wechat_redirect">众筹平台踩坑记 (qq.com)</a></p>
<p><a href="http://www.ityouknow.com/jvm/2017/09/30/jvm-ppt.html">jvm 系列(十):JVM 演讲 PPT 分享 - 纯洁的微笑博客 (ityouknow.com)</a></p>
<p><a href="#bjj">返回</a></p>
<p><a href="#back">返回</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA八股文]]></title>
        <id>https://clownjerome.github.io/post/java-ba-gu-wen/</id>
        <link href="https://clownjerome.github.io/post/java-ba-gu-wen/">
        </link>
        <updated>2021-10-08T09:59:46.000Z</updated>
        <content type="html"><![CDATA[<p>1、并发编程三要素？<br>
（1） 原子性<br>
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要 么就全部都不执行。</p>
<p>（2） 可见性<br>
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立 即看到修改的结果。</p>
<p>（3） 有序性<br>
有序性，即程序的执行顺序按照代码的先后顺序来执行。</p>
<p>2、实现可见性的方法有哪些？<br>
synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p>
<p>3、多线程的价值？<br>
（1） 发挥多核 CPU 的优势<br>
多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的，采用多线程的方式去同时完成几件事情而不互相干扰。</p>
<p>（2） 防止阻塞<br>
从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行， 哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>
<p>（3） 便于建模<br>
这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>
<p>4、创建线程的有哪些方式？<br>
（1） 继承 Thread 类创建线程类</p>
<p>（2） 通过 Runnable 接口创建线程类</p>
<p>（3） 通过 Callable 和 Future 创建线程</p>
<p>（4） 通过线程池创建</p>
<p>5、创建线程的三种方式的对比？<br>
（1） 采用实现 Runnable、Callable 接口的方式创建多线程。优势是：</p>
<p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况， 从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>劣势是：</p>
<p>编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法。</p>
<p>（2） 使用继承 Thread 类的方式创建多线程优势是：</p>
<p>编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this<br>
即可获得当前线程。劣势是：<br>
线程类已经继承了 Thread 类，所以不能再继承其他父类。</p>
<p>（3） Runnable 和 Callable 的区别<br>
1、Callable 规定（重写）的方法是 call()，Runnable 规定（重写）的方法是 run()。2、Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。<br>
3、Call 方法可以抛出异常，run 方法不可以。</p>
<p>4、运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
<p>6、线程的状态流转图<br>
线程的生命周期及五种基本状态：</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633687219332.png" alt="" loading="lazy"></figure>
<p>7、Java 线程具有五中基本状态<br>
（1） 新建状态（New）：<br>
当线程对象对创建后，即进入了新建状态，如：Thread t= new MyThread()；</p>
<p>（2） 就绪状态（Runnable）：<br>
当调用线程对象的 start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程， 只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 t.start()此线程立即就会执行；</p>
<p>（3） 运行状态（Running）：<br>
当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p>（4） 阻塞状态（Blocked）：<br>
处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻</p>
<p>塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：<br>
1） 等待阻塞：运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2） 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)， 它会进入同步阻塞状态；<br>
3） 其他阻塞：通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</p>
<p>（5） 死亡状态（Dead）：<br>
线程执行完了或者因异常退出了 run()方法，该线程结束生命周期。</p>
<p>8、什么是线程池？有哪几种创建方式？<br>
线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p>
<p>java 提供了一个 java.util.concurrent.Executor 接口的实现用于创建线程池。</p>
<p>9、四种线程池的创建：<br>
（1） newCachedThreadPool 创建一个可缓存线程池</p>
<p>（2） newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。</p>
<p>（3） newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>（4） newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。</p>
<p>10、线程池的优点？<br>
（1） 重用存在的线程，减少对象创建销毁的开销。</p>
<p>（2） 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避</p>
<p>免堵塞。</p>
<p>（3） 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<p>11、常用的并发工具类有哪些？<br>
（1） CountDownLatch</p>
<p>（2） CyclicBarrier</p>
<p>（3） Semaphore</p>
<p>（4） Exchanger</p>
<p>12、CyclicBarrier 和 CountDownLatch 的区别<br>
（1） CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行。</p>
<p>（2） cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方法之后， 所有线程同时开始执行！</p>
<p>（3） CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</p>
<p>（ 4 ） CyclicBarrier 还提供其他有用的方法， 比如 getNumberWaiting 方法可以获得CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。如果被中断返回 true，否则返回 false。</p>
<p>13、synchronized 的作用？<br>
在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。</p>
<p>14、volatile 关键字的作用<br>
对于可见性，Java 提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取</p>
<p>新值。从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p>
<p>15、什么是 CAS<br>
CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p>
<p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据， 性能较悲观锁有很大的提高。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<p>java.util.concurrent.atomic 包 下 的 类 大 多 是 使 用 CAS 操 作 来 实 现 的<br>
(AtomicInteger,AtomicBoolean,AtomicLong)。</p>
<p>16、CAS 的问题<br>
（1） CAS 容易造成 ABA 问题<br>
一个线程 a 将数值改成了 b，接着又改成了 a，此时 CAS 认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次 version 加 1。在 java5 中，已经提供了 AtomicStampedReference 来解决问题。</p>
<p>（2） 不能保证代码块的原子性<br>
CAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 3 个变量共同进行原子性的更新，就不得不使用 synchronized 了。</p>
<p>（3） CAS 造成 CPU 利用率增加<br>
之前说过了 CAS 里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu 资源会一直被占用。</p>
<p>17、什么是 Future？<br>
在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。</p>
<p>Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后作出相应的操作。</p>
<p>18、什么是 AQS<br>
AQS 是 AbustactQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管理这个同步状态。</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock， SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<p>19、AQS 支持两种同步方式：<br>
（1） 独占式<br>
（2） 共享式<br>
这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore， CountDownLatch，组 合 式 的 如 ReentrantReadWriteLock。总之，AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>20、ReadWriteLock 是什么<br>
首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的， 没有必要加锁， 但是还是加锁了， 降低了程序的性能。因为这个， 才诞生了读写锁ReadWriteLock 。 ReadWriteLock 是 一 个 读 写 锁 接 口 ， ReentrantReadWriteLock 是ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的， 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<p>21、FutureTask 是什么<br>
这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以FutureTask 也可以放入线程池中。</p>
<p>22、synchronized 和 ReentrantLock 的区别<br>
synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：</p>
<p>（1） ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁</p>
<p>（2） ReentrantLock 可以获取各种锁的信息</p>
<p>（3） ReentrantLock 可以灵活地实现多路通知</p>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。</p>
<p>23、什么是乐观锁和悲观锁<br>
（1） 乐观锁：<br>
就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<p>（2） 悲观锁：<br>
还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</p>
<p>24、线程 B 怎么知道线程 A 修改了变量<br>
（1） volatile 修饰变量</p>
<p>（2） synchronized 修饰修改变量的方法</p>
<p>（3） wait/notify</p>
<p>（4） while 轮询</p>
<p>25、synchronized、volatile、CAS 比较<br>
（1） synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</p>
<p>（2） volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p>
<p>（3） CAS 是基于冲突检测的乐观锁（非阻塞）</p>
<p>26、sleep 方法和 wait 方法有什么区别?<br>
这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</p>
<p>27、ThreadLocal 是什么？有什么用？<br>
ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用， 特别适用于各个线程依赖不通的变量值完成操作的场景。简单说 ThreadLocal 就是一种以空间 换 时 间 的 做 法 ， 在 每 个 Thread 里 面 维 护 了 一 个 以 开 地 址 法 实 现 的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<p>28、为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用<br>
这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<p>29、多线程同步有哪几种方法？<br>
Synchronized 关键字，Lock 锁实现，分布式锁等。</p>
<p>30、线程的调度策略<br>
线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p>
<p>（1） 线程体中调用了 yield 方法让出了对 cpu 的占用权利</p>
<p>（2） 线程体中调用了 sleep 方法使线程进入睡眠状态</p>
<p>（3） 线程由于 IO 操作受到阻塞</p>
<p>（4） 另外一个更高优先级线程出现</p>
<p>（5） 在支持时间片的系统中，该线程的时间片用完</p>
<p>31、ConcurrentHashMap 的并发度是什么<br>
ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有<br>
16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？</p>
<p>32、Linux 环境下如何查找哪个线程使用 CPU 最长<br>
（1） 获取项目的 pid，jps 或者 ps -ef | grep java</p>
<p>（2） top -H -p pid，顺序不能改变</p>
<p>33、Java 死锁以及如何避免？<br>
Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。</p>
<p>Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。</p>
<p>34、死锁的原因<br>
（1） 是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。例如：线程在获得了锁 A 并且没有释放的情况下去申请锁 B，这时，另一个线程已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循环。</p>
<p>（2） 默认的锁申请操作是阻塞的。<br>
所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的 所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用 其它对象的延时方法和同步方法。</p>
<p>35、怎么唤醒一个阻塞的线程<br>
如果线程是因为调用了 wait()、sleep()或 者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。</p>
<p>36、不可变对象对多线程有什么帮助<br>
前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需 要进行额外的同步手段，提升了代码执行效率。</p>
<p>37、什么是多线程的上下文切换<br>
多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p>
<p>38、如果你提交任务时，线程池队列已满，这时会发生什么<br>
这里区分一下：</p>
<p>（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p>
<p>（ 2 ） 如果 使 用的 是 有界 队 列 比如 ArrayBlockingQueue ， 任务 首 先会 被 添加 到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy</p>
<p>39、Java 中用到的线程调度算法是什么<br>
抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<p>40、什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)？<br>
线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<p>41、什么是自旋<br>
很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程</p>
<p>都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized 里面的代码执行得非常快， 不妨让等待锁的线程不要被阻塞， 而是在synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<p>42、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？<br>
Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1） 可以使锁更公平</p>
<p>（2） 可以使线程在等待锁的时候响应中断</p>
<p>（3） 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4） 可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>43、单例模式的线程安全性<br>
老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境 下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<p>（1） 饿汉式单例模式的写法：线程安全</p>
<p>（2） 懒汉式单例模式的写法：非线程安全</p>
<p>（3） 双检锁单例模式的写法：线程安全</p>
<p>44、Semaphore 有什么作用<br>
Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。</p>
<p>45、Executors 类是什么？<br>
Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable<br>
类提供了一些工具方法。Executors 可以用于方便的创建线程池</p>
<p>46、线程类的构造方法、静态块是被哪个线程调用的<br>
这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了 Thread1，main<br>
函数中 new 了 Thread2，那么：</p>
<p>（1） Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是 Thread2 自己调用的</p>
<p>（2） Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是 Thread1 自己调用的</p>
<p>47、同步方法和同步块，哪个是更好的选择?<br>
同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。 请知道一条原则：同步的范围越小越好。</p>
<p>48、Java 线程数过多会造成什么异常？<br>
（1） 线程的生命周期开销非常高<br>
（2） 消耗过多的 CPU 资源<br>
如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会 占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU 资源时还将产生其他性能的开销。</p>
<p>（3） 降低稳定性<br>
JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日零碎知识点Day1]]></title>
        <id>https://clownjerome.github.io/post/mei-ri-ling-sui-zhi-shi-dian-day1/</id>
        <link href="https://clownjerome.github.io/post/mei-ri-ling-sui-zhi-shi-dian-day1/">
        </link>
        <updated>2021-10-08T06:19:39.000Z</updated>
        <content type="html"><![CDATA[<p>JVM</p>
<p>jps：查看本机java进程信息。</p>
<p>jstack：打印线程的栈信息，制作线程dump文件。</p>
<p>jmap：打印内存映射，制作堆dump文件</p>
<p>jstat：性能监控工具</p>
<p>jhat：内存分析工具</p>
<p>jconsole：简易的可视化控制台</p>
<p>jvisualvm：功能强大的控制台</p>
<p>finally块一定会执行，无论是否try…catch。</p>
<p>finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p>
<p>finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p>
<p>MVC</p>
<p>MVC模式设计的web应用程序优点：可维护行强；可扩展性强；代码重复少</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633678163801.png" alt="" loading="lazy"></figure>
<p>Java中没有include关键字，导包用import</p>
<p>Java四种Import Declaration：</p>
<p>1.SingleTypeImportDeclaration，语法：import TypeName ;</p>
<p>2.TypeImportOnDemandDeclaretion，语法：import PackageOrTypeName . * ;</p>
<p>3.SingleStaticImportDeclaration，语法：import static TypeName . Identifier;</p>
<p>4.StaticImportOnDemandDeclaration，语法：import static TypeName . * ;</p>
<p>包装和基本类型不是同一个概念</p>
<p>long和double都占了64位（64bit）的存储空间</p>
<p>默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f</p>
<p>基本数据类型是没有静态方法的，但是基本数据类型的包装类却有</p>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
<p>​     通常，Java的异常(包括Exception和Error)分为 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions） 。<br>
​    可查异常（编译器要求必须处置的异常）：  正确的程序在运行中，很容易出现的、情理可容的异常状况 。 可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常 状况，就必须采取某种方式进行处理。</p>
<p>​	除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>​      不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p>
<p>​    运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p>非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<figure data-type="image" tabindex="2"><img src="https://clownjerome.github.io/post-images/1633678146485.png" alt="" loading="lazy"></figure>
<p>多态的作用是提高可重用性和扩展代码模块</p>
<p>封装的作用是隐藏细节</p>
<p>final</p>
<p>final类型的变量一定要初始化，因为final的变量不可更改</p>
<p>1，内部类声明在另一个类的内部，充当另一个类的成员变量，分为成员内部类，静态内部类，局部内部类，匿名内部类。</p>
<p>2，外部类访问内部类，必须创建内部类的对象</p>
<p>​    2.1，静态内部类：  外部类.内部类 引用名=new 外部类（）.内部类（）；</p>
<p>​    2.2，成员内部类：  外部类.内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>​      2.2.1，顶部引入内部类： import 包.外部类.内部类  内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>3，内部类访问外部类：因为内部类默认有外部类的引用，可以访问外部类的成员和方法，不需要创建对象</p>
<p>​    外部类.this.变量</p>
<p>4，一个源程序只能有一个public类与源文件同名，用public修饰的内部类可以不与源文件同名</p>
<p>5，外部类修饰符：public 包访问权限（默认）；成员内部类修饰符：public private protected 包访问权限</p>
<p>6，静态内部类可以有非静态成员，有静态成员的内部类一定是静态内部类，只可以访问外部的静态成员</p>
<p>7，局部内部类不可以有public，private，protected，static修饰符，只可以访问外部作用域的局部final变量</p>
<figure data-type="image" tabindex="3"><img src="https://clownjerome.github.io/post-images/1633678215749.png" alt="" loading="lazy"></figure>
<p>java中接口只能使用public修饰，接口内方法默认为public abstract</p>
<p>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；</p>
<p>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；</p>
<p>HttpSessionObjectListener：没有该接口API；</p>
<p>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；</p>
<p>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p>
<p>1、super()表示调用父类构造函数、this()调用自己的构造函数，而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况</p>
<p>2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中</p>
<p>3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。</p>
<p>局部变量参与运算前是必须要初始化</p>
<p>成员变量和静态变量是有默认值的</p>
<p>成员变量为int类型可以不初始化，默认值为0</p>
<p>局部变量为int类型必须初始化，没有默认值</p>
<p>int 类变量初始值0</p>
<p>boolean 类变量初始值false</p>
<p>char 类变量初始值'\u0000'</p>
<p>double 类变量初始值0.0</p>
<p>float 类变量初始值0.0f</p>
<p>long 类变量初始值0L</p>
<p>一旦在finally块中使用了return或throw语句，将会导致try块，catch块中的return，throw语句失效</p>
<p>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。</p>
<p>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</p>
<p>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</p>
<p>关键字volatile解决的下变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题</p>
<p>没有break，发生case穿透现象，程序会继续向下执行，直到遇到break或者结束switch语句的大括号为止。</p>
<p>String获取长度用的是length（）方法，而数组类型我们直接用属性length获取长度，所以String[]数组类型我们应该用length获取长度；2：总结来说，因为原字符串不包含分隔符，所以直接返回原字符串，分割出来只有一个空的字符串数组，所以结果是1.（注意，虽然原字符串为空，存到字符串数组为空，但是这个空也会算一个元素。）</p>
<p>并不是静态块最先初始化,而是静态域.</p>
<p>而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的</p>
<p>1.程序入口main方法要执行首先要加载类B</p>
<p>2.静态域：分为静态变量，静态方法，静态块。这里面涉及到的是静态变量和静态块，当执行到静态域时，按照静态域的顺序加载。并且静态域只在类的第一次加载时执行</p>
<p>3.每次new对象时，会执行一次构造块和构造方法，构造块总是在构造方法前执行（当然，第一次new时，会先执行静态域，静态域〉构造块〉构造方法）</p>
<p>​      注意：加载类时并不会调用构造块和构造方法，只有静态域会执行</p>
<p>public class B<br>
{<br>
public static B t1 = new B();<br>
public static B t2 = new B();<br>
{<br>
System.out.println(&quot;构造块&quot;);<br>
}<br>
static<br>
{<br>
System.out.println(&quot;静态块&quot;);<br>
}<br>
public static void main(String[] args)<br>
{<br>
B t = new B();<br>
}<br>
}</p>
<p>首先加载类B，执行静态域的第一个静态变量，static b1=new B，输出构造块和构造方法（空）。 这里不加载静态方法是因为执行了静态变量的初始化，意味着已经加载了B的静态域的一部分，这时候不能再加载另一个静态域了，否则属于重复加载 了（静态域必须当成一个整体来看待。否则加载会错乱）</p>
<p>wait(https://clownjerome.github.io/post-images/1633678250549.png)ject的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。</p>
<p>sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。</p>
<p>yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。</p>
<p>线程</p>
<p>JDK中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>尚未启动的线程处于这个状态。Thread thread = new Thread(new Runnable(){...});处于这个状态。</td>
<td>线程尚未启动的线程状态。当在程序中创建一个线程的时候Thread t = new Thread(Runnable);，线程处于NEW状态。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>可运行的线程处于这个状态。对应操作系统中的两种状态：ready和running，也就是说RUNNABLE状态既可以是可运行的，也可以是实际运行中的，有可能正在执行，也有可能没有正在执行。</td>
<td>可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统中的其他资源，比如处理器。也就是说， 这个状态就是可运行也可不运行的状态。注意Runnable ≠ Running。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞，进入synchronized修饰的方法或者代码块，等待监视器锁的线程处于这个状态。</td>
<td>进入synchronized修饰的方法或者代码块，等待监视器锁的阻塞线程的线程状态。比如，线程试图通过synchronized去获取监视器锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。等到获得了监视器锁之后会再次进入RUNNABLE状态。</td>
</tr>
<tr>
<td>WAITING</td>
<td>无限期等待另一个线程执行特定操作的线程处于这种状态。</td>
<td>调用以下方法之一，线程会处于等待状态：Object.wait()注意：括号内不带参数； Thread.join()注意：括号内不带参数； LockSupport.park();</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>正在等待另一个线程执行某个操作的线程在指定的等待时间内处于这种状态。</td>
<td>一个线程调用了以下方法之一（方法需要带具体的等待时间），会处于定时等待状态：Tread.sleep(long timeout) Object.wait(long timeout) Thread.join(long timeout) LockSupport.parkNanos() LockSupport.parkUntil()</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>已经退出的线程处于这个状态。</td>
<td>该线程已经执行完毕。执行完毕指的是线程正常执行完了run方法之后退出，也可以是遇到了未捕获的异常而退出。</td>
</tr>
</tbody>
</table>
<p>线程池</p>
<p>在JDK源码中，线程池（ThreadPoolExecutor）定义了五种状态：RUNNING、SHUTDOWN、STOP、TIDYING和TERMINATED。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>运行状态，可以添加新任务，也可以处理阻塞队列中的任务。</td>
<td>线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>待关闭状态，不再接受新的任务，会继续处理阻塞队列中的任务。</td>
<td>当线程池处于RUNNING状态时，调用shutdown()方法，线程池RUNNING状态转为SHUTDOWN状态。</td>
</tr>
<tr>
<td>STOP</td>
<td>停止状态，不再接受新的任务，不会执行阻塞队列中的任务，打断正在执行的任务。</td>
<td>当线程池处于RUNNING or SHUTDOWN时，调用shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN )状态转为STOP状态。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>整理状态，所有任务都处理完毕，workerCount为0，线程转到该状态将会运行terminated()钩子方法。</td>
<td>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN状态转为TIDYING状态。当线程池处于STOP状态，当线程池中执行的任务为空的时候，线程池有STOP状态转为TIDYING状态。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，terminated()方法执行完毕。</td>
<td>当线程池处于TIDYING状态，当执行完terminated()之后，就会由TIDYING状态转为TERMINATED状态。</td>
</tr>
</tbody>
</table>
<p>两个最基本的java回收算法：复制算法和标记清理算法</p>
<p>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<p>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出</p>
<p>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：新生代和年老代</p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记整理 ，局部采用复制</p>
<p>string是final修饰的，会将创建的变量放入字符串常量池，当再创建同样的字符串时，发现常量池中有则直接使用</p>
<p>a++访问a之后再对a进行加一操作</p>
<p>特殊变量super，提供了对父类的访问。<br>
可以使用super访问父类被子类隐藏的变量或覆盖的方法。<br>
每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>
构造是不能被继承的。</p>
<p>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p>
<p>类的加载顺序</p>
<p>(1) 父类静态对象和静态代码块</p>
<p>(2) 子类静态对象和静态代码块</p>
<p>(3) 父类非静态对象和非静态代码块</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类 非静态对象和非静态代码块</p>
<p>(6) 子类构造函数</p>
<p>join()的作用是：“等待该线程终止”</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。  //这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p>
<p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。//ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p>
<p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。//ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p>
<p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。//因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针。</p>
<figure data-type="image" tabindex="4"><img src="https://clownjerome.github.io/post-images/1633678114863.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://clownjerome.github.io/post-images/1633678122967.png" alt="" loading="lazy"></figure>
<p>没有模板不可能创建对象，创建对象必须先要定义类</p>
<p>对象中的数据域和方法取决于该对象的类，类里面有就有，没有就没有</p>
<p>数据域可以是基本类型变量，也可以是一个对象</p>
<p>数据域不一定是基本类型，也可以是引用类型</p>
<p>初始化块在构造器执行之前执行，类初始化阶段先执行最顶层父类的静态初始化块，依次向下执行，最后执行当前类的静态初始化块；创建对象时，先调用顶层父类的构造方法，依次向下执行，最后调用本类的构造方法。</p>
<p>实例方法：一个方法如果不加static关键字,那么这个方法是实例方法。意思就是他属于类的某个实例,通过这个实例调用它,对类的其他实例不产生影响.</p>
<p>类方法：也称静态方法。在方法前面加static关键字,就代表这个方法属于这个类本身,不属于他的任何实例,意思就是说,这个方法可以不通过实例调用,并且所有的实例都共享这一个方法,对方法的调用各个实例相互可见</p>
<p>start方法</p>
<p>​        用  start方法来启动线程，是真正实现了多线程，  通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p>
<p>run方法</p>
<p>​        run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p>
<p>instanceof可以用来判断某个实例变量是否属于某种类的类型，还可以判断某个类是否属于某个类的子类的类型。</p>
<p>&amp;与&amp;&amp;的异同点。</p>
<p>相同点：二者都表示与操作，当且仅当运算符两边的操作数都为true时，其结果才为true，否则为false。</p>
<p>不同点：在使用&amp;进行运算时，不论左边为true或者false，右边的表达式都会进行运算。如果使用&amp;&amp;进行运算时，当左边为false时，右边的表达式不会进行运算，因此&amp;&amp;被称作短路与。</p>
<p>|与||的异同点。</p>
<p>相同点：二者都表示或操作，当运算符两边的操作数任何一边的值为true时，其结果为true，当两边的值都为false时，其结果才为false。</p>
<p>不同点：同与操作类似，||表示短路或，当运算符左边的值为true时，右边的表达式不会进行运算。</p>
<p>&quot;?：&quot;: 三目运算符，三目运算符是右结合</p>
<p>静态内部类才可以声明静态方法</p>
<p>静态方法不可以使用非静态变量</p>
<p>抽象方法不可以有函数体</p>
<p>Thread实现了Runnable接口是一个类不是接口</p>
<p>实现多线程的三种方式，一种是继承Thread类使用此方式就不能继承其他的类了。还有两种是实现Runnable接口或者实现Callable接口</p>
<p>public 共有类；abstract 抽象类；final 不能被继承，没有子类；class 只能在包内使用的类</p>
<p>调用父类的无参构造用super（）</p>
<p>在 final 定义的方法里，不是必须要用 final 定义变量；final  定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化；final修饰方法，不能被子类重写，但是可以被重载；final 定义变量，可以用  static 也可以不用。</p>
<p>无论如何，Integer与new Integer不会相等。不会经历拆箱过程。<br>
两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。<br>
两个都是new出来的,都为false。<br>
int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。</p>
<p>父类静态代码块 &gt;子类静态代码块 &gt;父类非静态代码块 &gt; 父类构造函数 &gt; 子类非静态代码块 &gt; 子类构造函数。</p>
<p>Object默认9方法：getClass(),hashCode(),   equals(), clone(), toString(), notify(), notifyAll(),wait(), finalize()</p>
<figure data-type="image" tabindex="6"><img src="https://clownjerome.github.io/post-images/1633678074505.png" alt="" loading="lazy"></figure>
<p>身份证号表达式</p>
<p><code>isIDCard=/^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/</code></p>
<p><code>isIDCard=/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$/</code></p>
<p><code>^：起始符号，^x表示以x开头</code><br>
<code>$：结束符号，x$表示以x结尾</code><br>
[n-m]：表示从n到m的数字<br>
\d：表示数字，等同于[0-9]<br>
X{m}：表示由m个X字符构成，\d{4}表示4位数字</p>
<p>方法重载满足的条件</p>
<p>1.方法名必须相同；<br>
2.方法返回类型，修饰符可不同；<br>
3.参数类型或个数或顺序要不同。</p>
<p>String由final修饰，final不能被继承，不能被修改</p>
<p>String不可变的意义在于：</p>
<ol>
<li>字符串常量池的需要</li>
<li>允许String对象缓存HashCode</li>
<li>安全性</li>
</ol>
<p>StringBuffer是线程安全，StringBuilder线程不安全</p>
<p>速度：StringBuider&gt;StringBuffer&gt;String</p>
<p>一个.java文件中，可以有多个类，包括内部类和外部类。考虑到内部类的原因，一个.java文件中可以有多个public类。</p>
<p>但是对于外部类而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）。</p>
<p>Semaphore：类，控制某个资源可被同时访问的个数;</p>
<p>ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；</p>
<p>Future：接口，表示异步计算的结果；</p>
<p>CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</p>
<p>实例变量： 定义在类中的变量是类的成员变量，可以不进行初始化，  java  会自动进行初始化。（如果是引用类默认初始化为  null,  如果是基本类型，默认初始化为0）</p>
<p>局部变量：定义在方法中的变量，必须进行初始化，否则不通过编译。</p>
<p>类变量 ：（也叫作静态变量）是类中独立于方法之外的变量，用  static  修饰。</p>
<p>final 修饰的变量：也称为常量。</p>
<figure data-type="image" tabindex="7"><img src="https://clownjerome.github.io/post-images/1633678499329.png" alt="" loading="lazy"></figure>
<p>his的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；</p>
<p>super是调用父类的方法；</p>
<p>A(a)这种形式是在new一个类时使用。</p>
<p>Java三大注解分别是@Override@Deprecated@Suppresswarnings</p>
<p>@Override注解表名子类中覆盖了超类中的某个方法，如果写错了覆盖形式，编译器会报错</p>
<p>@Deprecated 表明不希望别人在以后使用这个类，方法，变量等等</p>
<p>@Suppresswarnings 达到抑制编译器产生警告的目的，但是不建议使用，因为后期编码人员看不懂编译器提示的警告，不能更好的选择更好的类去完成任务</p>
<p>Java中的关键字？</p>
<p>48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。</p>
<p>2个保留字（现在没用以后可能用到作为关键字）：goto、const。</p>
<p>3个特殊直接量：true、false、null。</p>
<p>Stack是栈， queue是对列；</p>
<p>栈是后进先出，对列是先进先出；</p>
<p>栈是出入从同一个位置；</p>
<p>对列是入从结构的一端进入，从另一端出队；</p>
<p>栈就像一个盒子，你把物体依次放入后，能先拿出来的只能是上面最后放进去的，下层的想要拿出需要将上层的先拿出，也就是先出栈；</p>
<p>对列是一个胡同，人们都进入胡同了，只有最前面的人从胡同出口出去，后面的人只有等前面的人走完后才能依次通过。</p>
<p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，先继承类再实现接口</p>
<p>抽象类可以有非抽象的方法，而接口中的方法都是抽象方法</p>
<p>java中类只能单继承，接口可以继承多个接口</p>
<p>抽象类必须有构造方法，接口一定没有构造方法</p>
<p>实例化一般指new一个对象，所以抽象类不能实例化</p>
<figure data-type="image" tabindex="8"><img src="https://clownjerome.github.io/post-images/1633677663238.png" alt="" loading="lazy"></figure>
<p>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。</p>
<p>Socket(InetAddress address ,int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。</p>
<p>socket和servletSocket的交互如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://clownjerome.github.io/post-images/1633677657618.png" alt="" loading="lazy"></figure>
<p>java.lang包包含</p>
<ul>
<li>包装类</li>
<li>String 类</li>
<li>Math 类   ——  包含函数</li>
<li>Class 类</li>
<li>Object 类</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以被任何类访问</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>可以被同一包中的所有类访问 可以被所有子类访问</td>
<td>子类没有在同一包中也可以访问</td>
</tr>
<tr>
<td>private</td>
<td>只能够被当前类的方法访问</td>
<td></td>
</tr>
<tr>
<td>缺省 无访问修饰符</td>
<td>可以被同一包中的所有类访问</td>
<td>如果子类没有在同一个包中，也不能访问</td>
</tr>
</tbody>
</table>
<p>不同类型数据间的优先关系如下：</p>
<p>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>HashSet子类依靠hashCode()，equals()方法区分重复元素。HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<p>intValue()是把Integer对象类型变成int的基础数据类型；<br>
parseInt()是把String  变成int的基础数据类型；<br>
Valueof()是把String  转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）</p>
<p>设置HTTP头标</p>
<p>response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); //三秒刷新页面一次</p>
<p>设置cookie</p>
<p>Cookie c1 = new<code></code>Cookie(&quot;username&quot;,&quot;only&quot;);response.addCookie(c1);</p>
<p>读取路径信息,request读取路径信息</p>
<p>从request获取各种路径总结 request.getRealPath(&quot;url&quot;); // 虚拟目录映射为实际目录request.getRealPath(&quot;./&quot;);  // 网页所在的目录request.getRealPath(&quot;../&quot;); // 网页所在目录的上一层目录request.getContextPath();  // 应用的web目录的名称</p>
<p>输出返回数据</p>
<p>HttpServleteResponse.getOutputStream().write();</p>
<p>System.arraycopy()：native方法+JVM手写函数，在JVM里预写好速度最快</p>
<p>clone()：native方法，但并未手写，需要JNI转换，速度其次</p>
<p>Arrays.copyof()：本质是调用1的方法</p>
<p>for()：全是深复制，并且不是封装方法，最慢情有可原</p>
<p>1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。而如果该关键字修饰的方法是static方法，则使用的锁就是class变量的锁；如果是修饰类方法，则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的，是在其子类实现的。所以，锁应该归其子类所有，所以，抽象方法也就不能用synchronized关键字修饰了；native这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？</p>
<p>2、接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用。而且protected访问修饰符也不能使用，因为接口可以让所有的类去实现（非继承），不只是其子类，但是要用public去修饰。接口可以去继承一个已有的接口。</p>
<p>类、方法、成员变量和局部变量的可用修饰符</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员访求</th>
<th>构造方法</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract（抽象的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>static（静态的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>public（公共的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>protected（受保护的）</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>private（私有的）</td>
<td>-</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>synchronized（同步的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>native（本地的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>transient（暂时的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>volatie（易失的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>final（不要改变的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>类 修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从其他类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abstract</td>
<td>本类不能被实例化</td>
</tr>
<tr>
<td>Final</td>
<td>不能再声明子类</td>
</tr>
</tbody>
</table>
<p>构造函数修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从自己的类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能在本类中访问</td>
</tr>
</tbody>
</table>
<p>域\成员变量修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>Static</td>
<td>对该类的所有实例只能有一个域值存在</td>
</tr>
<tr>
<td>transient</td>
<td>不是一个对象持久状态的一部份</td>
</tr>
<tr>
<td>Volatile</td>
<td>可以被异步的线程所修改</td>
</tr>
<tr>
<td>final</td>
<td>必须对它赋予初值并且不能修改它</td>
</tr>
</tbody>
</table>
<p>局部变量 修饰符</p>
<table>
<thead>
<tr>
<th>final</th>
<th>必须对它赋予初值并且不能修改它</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>方法修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问它</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类及其子类中访问它</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>abstract</td>
<td>没有方法体，属于一个抽象类</td>
</tr>
<tr>
<td>final</td>
<td>子类不能覆盖它</td>
</tr>
<tr>
<td>static</td>
<td>被绑定于类本身而不是类的实例</td>
</tr>
<tr>
<td>native</td>
<td>该方法由其他编程语言实现</td>
</tr>
<tr>
<td>asnchronized</td>
<td>在一个线程调用它之前必须先给它加</td>
</tr>
</tbody>
</table>
<p>类的修饰符整合</p>
<p>类</p>
<p>类的修饰符：</p>
<p>Public:可以在其他任何类中使用，默认为统一包下的任意类。</p>
<p>Abstract:抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。</p>
<p>Final:不能被继承。</p>
<p>变量</p>
<p>变量修饰符：</p>
<p>一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。</p>
<p>可访问修饰符：</p>
<p>static**：**类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。</p>
<p>final**：**常量。</p>
<p>volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。</p>
<p>实例变量：和类变量对应，即每个对象都拥有各自独立的实例变量。</p>
<p>方法：（和变量对象分为实例方法和类方法，并用有无static修饰区别）</p>
<p>类方法：使用static关键字说明的方法</p>
<p>1.第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。</p>
<p>2.类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。</p>
<p>实例方法：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。</p>
<p>方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）</p>
<p>方法的返回类型：若无返回类型，则声明为void.</p>
<p>方法中的变量作用域：</p>
<p>成员变量：整个类。</p>
<p>局部变量：定义起到方法块结束为止。</p>
<p>方法参数：整个方法或者构造方法。</p>
<p>异常处理参数：参数传递给异常处理方法。</p>
<p>构造方法：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。</p>
<p>静态初始化器：格式：static{&lt;赋值语句组&gt;}</p>
<p>静态初始化器与构造方法的区别：</p>
<table>
<thead>
<tr>
<th>静态初始化器</th>
<th>构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>对类的静态域初始化</td>
<td>对新建的对象初始化</td>
</tr>
<tr>
<td>类进入内存后，系统调用执行</td>
<td>执行new后自动执行</td>
</tr>
<tr>
<td>属特殊语句（仅执行一次）</td>
<td>属特殊方法</td>
</tr>
</tbody>
</table>
<p>方法的修饰符：</p>
<p>抽象方法：用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。</p>
<p>类方法：静态方法，用static修饰，</p>
<p>调用时，使用类名作为前缀，而不是类的某个实例对象名</p>
<p>不能被单独对象拥有，属于整个类共享。</p>
<p>不能处理成员变量。</p>
<p>最终方法：用final修饰，不能被子类重新定义的方法。</p>
<p>本地方法：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。</p>
<p>Java访问控制符的含义和使用情况</p>
<table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>java自动装箱，对于Integer和Double的自动装箱，只能装对应的数据类型，不对应就会报错。java中100默认是int型,而不是byte，short和long;100.0默认是double，而不是float。</p>
<p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p>
<p>AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。<br>
AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象 ，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。<br>
核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉， AOP只是OOP的补充，无替代关系。</p>
<figure data-type="image" tabindex="10"><img src="https://clownjerome.github.io/post-images/1633677626834.png" alt="" loading="lazy"></figure>
<p>Java中的四类八种基本数据类型</p>
<p>第一类：整数类型  byte short int long</p>
<p>第二类：浮点型  float double</p>
<p>第三类：逻辑型   boolean(它只有两个值可取true false)</p>
<p>第四类：字符型  char</p>
<p>Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度</p>
<p>start()方法是启动一个线程，此时的线程处于就绪状态，但并不一定就会执行，还需要等待CPU的调度。<br>
run()方法才是线程获得CPU时间，开始执行的点。</p>
<p>实现线程的方法有三种：<br>
第一种：继承Thread类覆盖父类的run()方法   创建子类对象 然后  对象.start();执行线程 run()方法执行<br>
第二种：实现Runnable接口 覆盖接口的run()方法   创建线程对象将子类传入，然后线程对象.start();启动线程  run()方法执行<br>
第三种：实现Callable接口  类似于Runnable接口<br>
Callable与Runnable接口的区别是：<br>
①Callable规定的方法是call()，而Runnable规定的方法是run().<br>
②Callable的任务执行后可返回值，而Runnable的任务是不能返回值的<br>
③call()方法可抛出异常，而run()方法是不能抛出异常的。<br>
④运行Callable任务可拿到一个Future对象，Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成,并检索计算的结果。通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果</p>
<p>throws 和 throw：</p>
<p>throws出现在方法头，表示可能会出现异常</p>
<p>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p>
<p>inputstream的close方法用来关闭流</p>
<p>skip()用来跳过一些字节</p>
<p>mark（）用来标记流</p>
<p>reset（）复位流</p>
<p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p>
<p>补充：</p>
<p>​          什么是类加载器？</p>
<p>​    把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>有哪些类加载器，分别加载哪些类</p>
<p>​    类加载器按照层次，从顶层到底层，分为以下三种：</p>
<p>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类</p>
<p>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p>
<p>(3)    应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p>
<p>​          双亲委派模型</p>
<p>​    我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为类加载器的双亲委派模型，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。</p>
<p>​          双亲委托模型的工作原理</p>
<p>​    是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p>
<p>​          使用双亲委派模型好处？（原因）</p>
<p>​    第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>​    第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器</p>
<p>（1）父类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（2）子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（3）父类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（4）执行父类构造方法。</p>
<p>（5）子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（6）执行子类构造方法</p>
<p>Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点。</p>
<p>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</p>
<p>(1)加载：Servlet容器（Tomcat）通过类加载器加载servlet文件（.class）</p>
<p>(2)创建：通过调用servlet构造函数创建一个servlet对象</p>
<p>(3)初始化：调用init方法初始化</p>
<p>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求</p>
<p>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>
<p>servlet是由Servlet容器负责加载Servlet类，创建Servlet对象并实例化，然后调用Servlet的init方法，进行初始化，之后调用Service方法。实例化和初始化不同。先实例化，再初始化。</p>
<p>再说一下ServletConfig和ServletContext</p>
<p>Jsp/Servlet容器初始化一个Servlet类型的对象时，会为这个Servlet对象创建一个ServletConfig对象。在ServletConfig对象中包含了Servlet的初始化参数信息。</p>
<p>ServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Webapp时，会为它创建一个ServletContext对象，即servlet上下文环境。每个webapp都有唯一的ServletContext对象。同一个webapp的所有servlet对象共享一个ServeltContext，servlet对象可以通过ServletContext来访问容器中的各种资源。</p>
<p>从作用范围来说，ServletConfig作用于某个特定的Servlet，即从该Servlet实例化，那么就开始有效，但是该Servlet之外的其他Servlet不能访问；ServletContext作用于某个webapp，即在一个webapp中相当于一个全局对象，在Servlet容器启动时就已经加载，对于不同的webapp，有不同的ServletContext。</p>
<p>最后，说明一下参数的获取。访问ServletConfig参数，取得ServletConfig对象后，调用getInitParameter()方法;访问ServletContext对象，只要调用现有的ServletConfig对象的getServletContext()即可，然后同样调用getInitParamter()方法就能获取参数。</p>
<figure data-type="image" tabindex="11"><img src="https://clownjerome.github.io/post-images/1633677569488.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://clownjerome.github.io/post-images/1633677561877.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://clownjerome.github.io/post/hello-world/</id>
        <link href="https://clownjerome.github.io/post/hello-world/">
        </link>
        <updated>2021-09-26T11:44:59.000Z</updated>
        <content type="html"><![CDATA[<CENTER><FONT face=隶书 color=red size=15>
<MARQUEE direction=up behavior=alternate width=60 height=120>我</MARQUEE>
<FONT color=yellow>
<MARQUEE direction=up behavior=alternate width=60 height=80>的</MARQUEE>
<FONT color=brown>
<MARQUEE direction=up behavior=alternate width=60 height=120>第</MARQUEE>
<FONT color=green>
<MARQUEE direction=up behavior=alternate width=60 height=80>一</MARQUEE>
<FONT color=orange>
<MARQUEE direction=up behavior=alternate width=60 height=120>篇</MARQUEE>
<FONT color=yellow>
<MARQUEE direction=up behavior=alternate width=60 height=80>文</MARQUEE>
<FONT color=orange>
<MARQUEE direction=up behavior=alternate width=60 height=120>章</MARQUEE>
</FONT>
</B>
</MARQUEE>
</FONT>
</CENTER>
</FONT>
</FONT>
</FONT>
</FONT>
</FONT>
</FONT>
<P style="text-align:center"><FONT color=#ff0000>希望在以</FONT><FONT color=#d52a00>后的日子</FONT><FONT color=#ab5400>里努力更</FONT><FONT color=#817e00>改及美化</FONT><FONT color=#57a800>我的博</FONT><FONT color=#2dd200>客世界</FONT>🥂</P>
<P style="text-align:center"><FONT face="楷体" >文章千古事，得失寸心知。</BR>
作者皆殊列，名声岂浪垂。</BR>
骚人嗟不见，汉道盛于斯。</BR>
前辈飞腾入，馀波绮丽为。</BR>
后贤兼旧列，历代各清规。</BR>
法自儒家有，心从弱岁疲。</BR>
永怀江左逸，多病邺中奇。</BR>
騄骥皆良马，骐驎带好儿。</BR>
车轮徒已斫，堂构惜仍亏。</BR>
漫作潜夫论，虚传幼妇碑。</BR>
缘情慰漂荡，抱疾屡迁移。</BR>
经济惭长策，飞栖假一枝。</BR>
尘沙傍蜂虿，江峡绕蛟螭。</BR>
萧瑟唐虞远，联翩楚汉危。</BR>
圣朝兼盗贼，异俗更喧卑。</BR>
郁郁星辰剑，苍苍云雨池。</BR>
两都开幕府，万宇插军麾。</BR>
南海残铜柱，东风避月支。</BR>
音书恨乌鹊，号怒怪熊罴。</BR>
稼穑分诗兴，柴荆学土宜。</BR>
故山迷白阁，秋水隐黄陂。</BR>
不敢要佳句，愁来赋别离。</BR>
——杜甫·偶题</FOUNT></P>
]]></content>
    </entry>
</feed>
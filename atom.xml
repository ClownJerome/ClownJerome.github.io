<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://clownjerome.github.io</id>
    <title>陈思羽</title>
    <updated>2021-10-08T13:06:05.872Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://clownjerome.github.io"/>
    <link rel="self" href="https://clownjerome.github.io/atom.xml"/>
    <subtitle>天道酬勤</subtitle>
    <logo>https://clownjerome.github.io/images/avatar.png</logo>
    <icon>https://clownjerome.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 陈思羽</rights>
    <entry>
        <title type="html"><![CDATA[JAVA八股文]]></title>
        <id>https://clownjerome.github.io/post/java-ba-gu-wen/</id>
        <link href="https://clownjerome.github.io/post/java-ba-gu-wen/">
        </link>
        <updated>2021-10-08T09:59:46.000Z</updated>
        <content type="html"><![CDATA[<p>1、并发编程三要素？<br>
（1） 原子性<br>
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要 么就全部都不执行。</p>
<p>（2） 可见性<br>
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立 即看到修改的结果。</p>
<p>（3） 有序性<br>
有序性，即程序的执行顺序按照代码的先后顺序来执行。</p>
<p>2、实现可见性的方法有哪些？<br>
synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p>
<p>3、多线程的价值？<br>
（1） 发挥多核 CPU 的优势<br>
多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的，采用多线程的方式去同时完成几件事情而不互相干扰。</p>
<p>（2） 防止阻塞<br>
从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行， 哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>
<p>（3） 便于建模<br>
这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>
<p>4、创建线程的有哪些方式？<br>
（1） 继承 Thread 类创建线程类</p>
<p>（2） 通过 Runnable 接口创建线程类</p>
<p>（3） 通过 Callable 和 Future 创建线程</p>
<p>（4） 通过线程池创建</p>
<p>5、创建线程的三种方式的对比？<br>
（1） 采用实现 Runnable、Callable 接口的方式创建多线程。优势是：</p>
<p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况， 从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>劣势是：</p>
<p>编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法。</p>
<p>（2） 使用继承 Thread 类的方式创建多线程优势是：</p>
<p>编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this<br>
即可获得当前线程。劣势是：<br>
线程类已经继承了 Thread 类，所以不能再继承其他父类。</p>
<p>（3） Runnable 和 Callable 的区别<br>
1、Callable 规定（重写）的方法是 call()，Runnable 规定（重写）的方法是 run()。2、Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。<br>
3、Call 方法可以抛出异常，run 方法不可以。</p>
<p>4、运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
<p>6、线程的状态流转图<br>
线程的生命周期及五种基本状态：</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633687219332.png" alt="" loading="lazy"></figure>
<p>7、Java 线程具有五中基本状态<br>
（1） 新建状态（New）：<br>
当线程对象对创建后，即进入了新建状态，如：Thread t= new MyThread()；</p>
<p>（2） 就绪状态（Runnable）：<br>
当调用线程对象的 start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程， 只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 t.start()此线程立即就会执行；</p>
<p>（3） 运行状态（Running）：<br>
当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p>（4） 阻塞状态（Blocked）：<br>
处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻</p>
<p>塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：<br>
1） 等待阻塞：运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2） 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)， 它会进入同步阻塞状态；<br>
3） 其他阻塞：通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</p>
<p>（5） 死亡状态（Dead）：<br>
线程执行完了或者因异常退出了 run()方法，该线程结束生命周期。</p>
<p>8、什么是线程池？有哪几种创建方式？<br>
线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p>
<p>java 提供了一个 java.util.concurrent.Executor 接口的实现用于创建线程池。</p>
<p>9、四种线程池的创建：<br>
（1） newCachedThreadPool 创建一个可缓存线程池</p>
<p>（2） newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。</p>
<p>（3） newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>（4） newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。</p>
<p>10、线程池的优点？<br>
（1） 重用存在的线程，减少对象创建销毁的开销。</p>
<p>（2） 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避</p>
<p>免堵塞。</p>
<p>（3） 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<p>11、常用的并发工具类有哪些？<br>
（1） CountDownLatch</p>
<p>（2） CyclicBarrier</p>
<p>（3） Semaphore</p>
<p>（4） Exchanger</p>
<p>12、CyclicBarrier 和 CountDownLatch 的区别<br>
（1） CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行。</p>
<p>（2） cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方法之后， 所有线程同时开始执行！</p>
<p>（3） CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</p>
<p>（ 4 ） CyclicBarrier 还提供其他有用的方法， 比如 getNumberWaiting 方法可以获得CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。如果被中断返回 true，否则返回 false。</p>
<p>13、synchronized 的作用？<br>
在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。</p>
<p>14、volatile 关键字的作用<br>
对于可见性，Java 提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取</p>
<p>新值。从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p>
<p>15、什么是 CAS<br>
CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p>
<p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据， 性能较悲观锁有很大的提高。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<p>java.util.concurrent.atomic 包 下 的 类 大 多 是 使 用 CAS 操 作 来 实 现 的<br>
(AtomicInteger,AtomicBoolean,AtomicLong)。</p>
<p>16、CAS 的问题<br>
（1） CAS 容易造成 ABA 问题<br>
一个线程 a 将数值改成了 b，接着又改成了 a，此时 CAS 认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次 version 加 1。在 java5 中，已经提供了 AtomicStampedReference 来解决问题。</p>
<p>（2） 不能保证代码块的原子性<br>
CAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 3 个变量共同进行原子性的更新，就不得不使用 synchronized 了。</p>
<p>（3） CAS 造成 CPU 利用率增加<br>
之前说过了 CAS 里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu 资源会一直被占用。</p>
<p>17、什么是 Future？<br>
在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。</p>
<p>Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后作出相应的操作。</p>
<p>18、什么是 AQS<br>
AQS 是 AbustactQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管理这个同步状态。</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock， SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<p>19、AQS 支持两种同步方式：<br>
（1） 独占式<br>
（2） 共享式<br>
这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore， CountDownLatch，组 合 式 的 如 ReentrantReadWriteLock。总之，AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>20、ReadWriteLock 是什么<br>
首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的， 没有必要加锁， 但是还是加锁了， 降低了程序的性能。因为这个， 才诞生了读写锁ReadWriteLock 。 ReadWriteLock 是 一 个 读 写 锁 接 口 ， ReentrantReadWriteLock 是ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的， 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<p>21、FutureTask 是什么<br>
这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以FutureTask 也可以放入线程池中。</p>
<p>22、synchronized 和 ReentrantLock 的区别<br>
synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：</p>
<p>（1） ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁</p>
<p>（2） ReentrantLock 可以获取各种锁的信息</p>
<p>（3） ReentrantLock 可以灵活地实现多路通知</p>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。</p>
<p>23、什么是乐观锁和悲观锁<br>
（1） 乐观锁：<br>
就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<p>（2） 悲观锁：<br>
还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</p>
<p>24、线程 B 怎么知道线程 A 修改了变量<br>
（1） volatile 修饰变量</p>
<p>（2） synchronized 修饰修改变量的方法</p>
<p>（3） wait/notify</p>
<p>（4） while 轮询</p>
<p>25、synchronized、volatile、CAS 比较<br>
（1） synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</p>
<p>（2） volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p>
<p>（3） CAS 是基于冲突检测的乐观锁（非阻塞）</p>
<p>26、sleep 方法和 wait 方法有什么区别?<br>
这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</p>
<p>27、ThreadLocal 是什么？有什么用？<br>
ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用， 特别适用于各个线程依赖不通的变量值完成操作的场景。简单说 ThreadLocal 就是一种以空间 换 时 间 的 做 法 ， 在 每 个 Thread 里 面 维 护 了 一 个 以 开 地 址 法 实 现 的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<p>28、为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用<br>
这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<p>29、多线程同步有哪几种方法？<br>
Synchronized 关键字，Lock 锁实现，分布式锁等。</p>
<p>30、线程的调度策略<br>
线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p>
<p>（1） 线程体中调用了 yield 方法让出了对 cpu 的占用权利</p>
<p>（2） 线程体中调用了 sleep 方法使线程进入睡眠状态</p>
<p>（3） 线程由于 IO 操作受到阻塞</p>
<p>（4） 另外一个更高优先级线程出现</p>
<p>（5） 在支持时间片的系统中，该线程的时间片用完</p>
<p>31、ConcurrentHashMap 的并发度是什么<br>
ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有<br>
16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？</p>
<p>32、Linux 环境下如何查找哪个线程使用 CPU 最长<br>
（1） 获取项目的 pid，jps 或者 ps -ef | grep java</p>
<p>（2） top -H -p pid，顺序不能改变</p>
<p>33、Java 死锁以及如何避免？<br>
Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。</p>
<p>Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。</p>
<p>34、死锁的原因<br>
（1） 是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。例如：线程在获得了锁 A 并且没有释放的情况下去申请锁 B，这时，另一个线程已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循环。</p>
<p>（2） 默认的锁申请操作是阻塞的。<br>
所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的 所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用 其它对象的延时方法和同步方法。</p>
<p>35、怎么唤醒一个阻塞的线程<br>
如果线程是因为调用了 wait()、sleep()或 者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。</p>
<p>36、不可变对象对多线程有什么帮助<br>
前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需 要进行额外的同步手段，提升了代码执行效率。</p>
<p>37、什么是多线程的上下文切换<br>
多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p>
<p>38、如果你提交任务时，线程池队列已满，这时会发生什么<br>
这里区分一下：</p>
<p>（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p>
<p>（ 2 ） 如果 使 用的 是 有界 队 列 比如 ArrayBlockingQueue ， 任务 首 先会 被 添加 到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy</p>
<p>39、Java 中用到的线程调度算法是什么<br>
抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<p>40、什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)？<br>
线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<p>41、什么是自旋<br>
很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程</p>
<p>都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized 里面的代码执行得非常快， 不妨让等待锁的线程不要被阻塞， 而是在synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<p>42、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？<br>
Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1） 可以使锁更公平</p>
<p>（2） 可以使线程在等待锁的时候响应中断</p>
<p>（3） 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4） 可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>43、单例模式的线程安全性<br>
老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境 下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<p>（1） 饿汉式单例模式的写法：线程安全</p>
<p>（2） 懒汉式单例模式的写法：非线程安全</p>
<p>（3） 双检锁单例模式的写法：线程安全</p>
<p>44、Semaphore 有什么作用<br>
Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。</p>
<p>45、Executors 类是什么？<br>
Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable<br>
类提供了一些工具方法。Executors 可以用于方便的创建线程池</p>
<p>46、线程类的构造方法、静态块是被哪个线程调用的<br>
这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了 Thread1，main<br>
函数中 new 了 Thread2，那么：</p>
<p>（1） Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是 Thread2 自己调用的</p>
<p>（2） Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是 Thread1 自己调用的</p>
<p>47、同步方法和同步块，哪个是更好的选择?<br>
同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。 请知道一条原则：同步的范围越小越好。</p>
<p>48、Java 线程数过多会造成什么异常？<br>
（1） 线程的生命周期开销非常高<br>
（2） 消耗过多的 CPU 资源<br>
如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会 占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU 资源时还将产生其他性能的开销。</p>
<p>（3） 降低稳定性<br>
JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML常用字体代码摘自CSDN]]></title>
        <id>https://clownjerome.github.io/post/html-chang-yong-zi-ti-dai-ma-zhai-zi-csdn/</id>
        <link href="https://clownjerome.github.io/post/html-chang-yong-zi-ti-dai-ma-zhai-zi-csdn/">
        </link>
        <updated>2021-10-08T06:38:39.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-html">常用字体
&lt;FONT style=&quot;FONT-SIZE: 40pt; FILTER: shadow(color=green); WIDTH: 100%; 
COLOR: white; LINE-HEIGHT: 150%; FONT-FAMILY: 华文彩云&quot;&gt;&lt;B&gt;常用字体&lt;/B&gt;&lt;/FONT&gt;  

*朋友别哭*
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-WEIGHT: bolder; FONT-SIZE: 70px; FILTER: 
blur(add=1, direction=45,strength=10); WIDTH: 450px; POSITION: relative&quot; 
color=#3333cc&gt;朋友别哭&lt;/FONT&gt;&lt;/CAPTION&gt; &lt;BR&gt;&lt;/CAPTION&gt;&lt;/P&gt;

总有一天等到你！
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-WEIGHT: bolder; FONT-SIZE: 50px; FILTER: 
blur(add=1, direction=45,strength=10); WIDTH: 500px; POSITION: relative&quot;&gt;
&lt;P&gt;&lt;FONT color=#ff00ff&gt;总有一天等到你！ &lt;/FONT&gt;&lt;/P&gt;&lt;/FONT&gt;&lt;/CAPTION&gt;
&lt;DIV&gt;&lt;/DIV&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;

华文行楷！
&lt;/B&gt;&lt;BR&gt;&lt;/B&gt;&lt;FONT style=&quot;FONT-SIZE: 50pt; FILTER: shadow(color=#af2dco); 
WIDTH: 100%; COLOR: #730404; LINE-HEIGHT: 100%; FONT-FAMILY: 华文行楷&quot; size=6&gt;
华文行楷！&lt;/FONT&gt;
&lt;DIV&gt;&lt;/DIV&gt;&lt;BR&gt;&lt;BR&gt;&lt;/DIV&gt;

&lt;CENTER&gt;
&lt;DIV style=&quot;FONT-SIZE: 52pt; FILTER: glow(color=ffff00, strength=5); WIDTH: 
350px; COLOR: red; FONT-FAMILY: Arial; POSITION: relative&quot;&gt;圈边的字&lt;/DIV&gt;&lt;/
CENTER&gt;&lt;BR&gt;&lt;/DIV&gt;

大家好！
&lt;CENTER&gt;&lt;FONT style=&quot;FONT-SIZE: 60pt; FILTER: shadow(color=black); WIDTH: 
100%; COLOR: #e4dc9b; LINE-HEIGHT: 150%; FONT-FAMILY: 华文彩云&quot;&gt;&lt;B&gt;
&lt;P&gt;大家好！&lt;/P&gt;&lt;/B&gt;&lt;/FONT&gt;&lt;/CENTER&gt;&lt;/DIV&gt;

一声问候...
&lt;FONT style=&quot;FONT-SIZE: 55pt; FILTER: shadow(color=#AF0530); WIDTH: 100%; 
COLOR: #f90b46; LINE-HEIGHT: 150%; FONT-FAMILY: 隶书&quot;&gt;&lt;B&gt;一声问候...&lt;/B&gt;&lt;/
FONT&gt;&lt;/DIV&gt;

&lt;FONT style=&quot;FONT-WEIGHT: bolder; FONT-SIZE: 70px; FILTER: blur(add=1, 
direction=45,strength=10); WIDTH: 450px; POSITION: relative&quot; color=#3333cc&gt;别
忘了,,,,&lt;/FONT&gt;&lt;/CAPTION&gt; &lt;BR&gt;&lt;/CAPTION&gt;&lt;/P&gt;&lt;BR&gt;&lt;/DIV&gt;

有空来坐坐*，，
&lt;DIV style=&quot;FILTER: shadow(color=#6495ED, strength=60); WIDTH: 480px&quot;&gt;&lt;FONT 
face=华文彩云 color=#9932cc size=7&gt;&lt;B&gt;
&lt;CENTER&gt;&lt;BR&gt;有空来坐坐*，，&lt;/CENTER&gt;
&lt;CENTER&gt;&lt;/B&gt;&amp;nbsp;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/DIV&gt;&lt;/DIV&gt;

朋友，欢迎您的到来~*.~.
朋友，欢迎您的到来~*.~.
&lt;CENTER&gt;
&lt;MARQUEE scrollAmount=2 direction=down height=60&gt;
&lt;CENTER&gt;&lt;FONT face=华文彩云 color=#da70d6 size=6&gt;&lt;B&gt;朋友，欢迎您的到来~~~~&lt;/
FONT&gt;&lt;/CENTER&gt;&lt;/B&gt;&lt;/MARQUEE&gt;
&lt;CENTER&gt;
&lt;MARQUEE scrollAmount=2 direction=up height=60&gt;
&lt;CENTER&gt;&lt;FONT face=华文彩云 color=#da70d6 size=6&gt;&lt;B&gt;朋友，欢迎您的到来~~~~&lt;/
FONT&gt;&lt;/CENTER&gt;&lt;/B&gt;&lt;/MARQUEE&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;P&gt;&lt;/P&gt;&lt;/CENTER&gt;

圈边的字
&lt;DIV align=center&gt;
&lt;DIV style=&quot;FILTER: shadow(color=#c299ff, strength=40); WIDTH: 480px&quot;&gt;&lt;FONT 
style=&quot;FONT-WEIGHT: normal; FONT-SIZE: 150pt; LINE-HEIGHT: normal; 
FONT-STYLE: normal; FONT-VARIANT: normal&quot; face=华文彩云 color=#fff000&gt;柳&lt;/
FONT&gt; &lt;BR&gt;&lt;/DIV&gt;&lt;/DIV&gt;&lt;/DIV&gt;

HTML标签！
&lt;FONT style=&quot;FONT-SIZE: 30pt; FILTER: shadow(color=red); WIDTH: 100%; COLOR: 
green; LINE-HEIGHT: 150%; FONT-FAMILY: 华文彩云&quot;&gt;&lt;B&gt;HTML标签！&lt;/B&gt;&lt;/FONT&gt;&lt;BR&gt;&lt;/
DIV&gt;

&lt;MARQUEE width=250 height=50&gt;&lt;IMG src=&quot;http://www.dabaoku.com/gif/154/
gif034.gif&quot;&gt;&lt;FONT face=隶书 color=#ff0000 size=7&gt; 查看论坛限制&lt;IMG src=&quot;http://
www.dabaoku.com/gif/154/gif034.gif&quot;&gt;&lt;/FONT&gt;&lt;/MARQUEE&gt;&lt;/FONT&gt;
&lt;MARQUEE direction=right width=250 height=50&gt;&lt;IMG src=&quot;http://www.dabaoku.com/
gif/154/gif033.gif&quot;&gt;&lt;FONT face=隶书 color=#ff0000 size=7&gt; 查看论坛限制&lt;IMG 
src=&quot;http://www.dabaoku.com/gif/154/gif033.gif&quot;&gt;&lt;/FONT&gt;&lt;/MARQUEE&gt;&lt;/FONT&gt;&lt;/DIV&gt;

巍巍大山*
&lt;MARQUEE direction=up&gt;
&lt;TABLE cellSpacing=0 cellPadding=0 align=center background=http://
xz7.2000y.net/admin/uploadfile/20044119194846010.jpg&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TD style=&quot;FILTER: chroma(color=#336699)&quot;&gt;
&lt;TABLE align=center bgColor=lime&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TD align=middle&gt;&lt;FONT style=&quot;FONT-SIZE: 60pt&quot; face=华文行楷 color=#336699&gt;巍巍
    大山、&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
    &lt;/FONT&gt;&lt;/MARQUEE&gt;&lt;/DIV&gt;

落入凡间的精灵
&lt;/B&gt;&lt;BR&gt;&lt;FONT style=&quot;FONT-SIZE: 55pt; FILTER: shadow(color=apar); WIDTH: 100%;
 COLOR: #00ff00; LINE-HEIGHT: 100%&quot; face=汉鼎繁随意 size=6&gt;落入凡间的精灵&lt;/
 FONT&gt;&lt;FONT style=&quot;FONT-SIZE: 55pt; FILTER: shadow(color=apar); WIDTH: 100%; 
 COLOR: #ff00ff; LINE-HEIGHT: 100%; FONT-FAMILY: 汉鼎繁中变&quot; size=6&gt;&lt;/
 FONT&gt;&lt;FONT color=#ff00ff&gt; &lt;/FONT&gt;
&lt;DIV&gt;&lt;/DIV&gt;
&lt;P&gt;&lt;/P&gt;

落 入 凡 间 的 精 灵
&lt;CENTER&gt;&lt;FONT face=隶书 color=red size=15&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;落&lt;/
MARQUEE&gt;&lt;FONT color=yellow&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;入&lt;/MARQUEE&gt;&lt;FONT 
color=brown&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;凡&lt;/
MARQUEE&gt;&lt;FONT color=green&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;间&lt;/MARQUEE&gt;&lt;FONT 
color=orange&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;的&lt;/
MARQUEE&gt;&lt;FONT color=yellow&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;精&lt;/MARQUEE&gt;&lt;FONT 
color=orange&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;灵&lt;/MARQUEE&gt;&lt;/
FONT&gt;&lt;/B&gt;&lt;/MARQUEE&gt;&lt;/FONT&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;
&lt;/FONT&gt;

想念绿色的春天
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-SIZE: 60pt; FILTER: shadow
(color=lime#b0c4de); WIDTH: 100%; COLOR: green; LINE-HEIGHT: 150%; 
FONT-FAMILY: 华文行楷&quot;&gt;&lt;B&gt;想念绿色的春天&lt;/FONT&gt;&lt;/B&gt;&lt;/P&gt;


躲藏在感情的背后
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-SIZE: 35pt; FILTER: glow(color=black); 
WIDTH: 100%; COLOR: #e4dc9b; LINE-HEIGHT: 150%; FONT-FAMILY: 楷体_GB2312&quot;&gt;
&lt;CENTER&gt;
&lt;P&gt;&lt;B&gt;&lt;FONT size=7&gt;躲藏在感情的背后 &lt;/FONT&gt;&lt;/B&gt;&lt;/P&gt;

爱在深秋
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-SIZE: 45pt; FILTER: shadow(color=#6495ED,
strength=15); WIDTH: 100%; COLOR: #00ffff; LINE-HEIGHT: 150%; FONT-FAMILY: 方
正舒体&quot;&gt;爱在深秋&lt;/FONT&gt;&lt;/P&gt;

爱在深秋
&lt;P align=center&gt;&lt;FONT style=&quot;FILTER: shadow(color=RED); WIDTH: 100%; COLOR: 
yellow; LINE-HEIGHT: 150%; FONT-FAMILY: 楷体_GB2312&quot; size=6&gt;
&lt;P align=center&gt;&lt;B&gt;爱在深秋&lt;/B&gt;&lt;/P&gt;

仿佛
成熟的季节成熟这一段情缘
&lt;P align=center&gt;&lt;FONT style=&quot;FONT-SIZE: 25pt; FILTER: shadow(color=#AF0530); 
WIDTH: 100%; COLOR: #00ccff; LINE-HEIGHT: 150%; FONT-FAMILY: 华文行楷&quot;&gt;&lt;B&gt;仿佛
    &lt;BR&gt;成熟的季节成熟这一段情缘&lt;/B&gt;&lt;/FONT&gt; 

编辑
&lt;CENTER&gt;&lt;FONT style=&quot;FONT-SIZE: 50pt; FILTER: shadow(color=black); WIDTH: 
100%; COLOR: #6495ed; LINE-HEIGHT: 150%; face: 新宋体&quot;&gt;&lt;B&gt;编辑&lt;/B&gt;&lt;/FONT&gt;&lt;/
CENTER&gt;


欢迎来到这里！
&lt;/B&gt;&lt;FONT style=&quot;FONT-SIZE: 50pt; FILTER: shadow(color=#af2dco); WIDTH: 100%; 
COLOR: #730404; LINE-HEIGHT: 100%; FONT-FAMILY: 华文行楷&quot; size=6&gt;欢迎来到这里！&lt;/
FONT&gt;
&lt;DIV&gt;&lt;/DIV&gt;&lt;BR&gt;&lt;BR&gt;

大家好！
&lt;/B&gt;
&lt;CENTER&gt;&lt;FONT style=&quot;FONT-SIZE: 60pt; FILTER: shadow(color=black); WIDTH: 
100%; COLOR: #e4dc9b; LINE-HEIGHT: 150%; FONT-FAMILY: 华文彩云&quot;&gt;&lt;B&gt;
&lt;P&gt;大家好！&lt;/P&gt;&lt;/B&gt;&lt;/FONT&gt;&lt;/CENTER&gt;

这里有美丽的风景
&lt;FONT style=&quot;FONT-SIZE: 45pt; FILTER: shadow(color=#AF0530); WIDTH: 100%; 
COLOR: #f90b46; LINE-HEIGHT: 150%; FONT-FAMILY: 隶书&quot;&gt;&lt;B&gt;这里有美丽的风景&lt;/B&gt;&lt;/
FONT&gt;

&lt;CENTER&gt;&lt;FONT face=隶书 color=red size=15&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;祝&lt;/
MARQUEE&gt;&lt;FONT color=yellow&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;大&lt;/MARQUEE&gt;&lt;FONT 
color=brown&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;家&lt;/
MARQUEE&gt;&lt;FONT color=green&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;周&lt;/MARQUEE&gt;&lt;FONT 
color=orange&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;末&lt;/
MARQUEE&gt;&lt;FONT color=yellow&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=80&gt;愉&lt;/MARQUEE&gt;&lt;FONT 
color=orange&gt;
&lt;MARQUEE direction=up behavior=alternate width=60 height=120&gt;快&lt;/MARQUEE&gt;&lt;/
FONT&gt;&lt;/B&gt;&lt;/MARQUEE&gt;&lt;/FONT&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;&lt;/FONT&gt;
&lt;/FONT&gt;
 
大家好!*!*
大家好!^!^
&lt;MARQUEE scrollAmount=2 direction=down height=60&gt;
&lt;CENTER&gt;&lt;FONT face=隶书 color=#f73809 size=7&gt;&lt;B&gt;大家好!*!*&lt;/FONT&gt;&lt;/CENTER&gt;&lt;/
B&gt;&lt;/MARQUEE&gt;
&lt;CENTER&gt;
&lt;MARQUEE scrollAmount=2 direction=up height=60&gt;
&lt;CENTER&gt;&lt;FONT face=华文彩云 color=#4db361 size=6&gt;&lt;B&gt;大家好!^!^&lt;/FONT&gt;&lt;/CENTER&gt;&lt;/
B&gt;&lt;/MARQUEE&gt;&lt;/CENTER&gt;
&lt;DIV&gt;&lt;/DIV&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;
&lt;CENTER&gt;&lt;/CENTER&gt;

朋友您辛苦了!
&lt;MARQUEE direction=up&gt;
&lt;TABLE cellSpacing=0 cellPadding=0 align=center background=http://
znrs.2000y.net/UploadFile/2004-5/2004510115258900.jpg&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TD style=&quot;FILTER: chroma(color=#336699)&quot;&gt;
&lt;TABLE align=center bgColor=red&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TD align=middle&gt;&lt;FONT style=&quot;FONT-SIZE: 60pt&quot; face=华文行楷 color=#336699&gt;朋友
    您辛苦了!&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/
    TABLE&gt;&lt;/FONT&gt;&lt;/MARQUEE&gt;&lt;/DIV&gt;

这里是你我的家
&lt;FONT size=7&gt;&lt;FONT color=#ff0000&gt;这&lt;/FONT&gt;&lt;FONT color=#d52a00&gt;里&lt;/FONT&gt;&lt;FONT 
color=#ab5400&gt;是&lt;/FONT&gt;&lt;FONT color=#817e00&gt;你&lt;/FONT&gt;&lt;FONT color=#57a800&gt;我&lt;/
FONT&gt;&lt;FONT color=#2dd200&gt;的家&lt;/FONT&gt;&lt;/FONT&gt;

&lt;CENTER&gt;&lt;FONT style=&quot;FONT-SIZE: 40pt; FILTER: glow(color=black); WIDTH: 100%; 
COLOR: #e4dc9b; LINE-HEIGHT: 150%; FONT-FAMILY: 华文彩云&quot;&gt;&lt;B&gt;一杯热茶~*&lt;/B&gt;&lt;/
FONT&gt;&lt;/CENTER&gt;&lt;/DIV&gt;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日零碎知识点Day1]]></title>
        <id>https://clownjerome.github.io/post/mei-ri-ling-sui-zhi-shi-dian-day1/</id>
        <link href="https://clownjerome.github.io/post/mei-ri-ling-sui-zhi-shi-dian-day1/">
        </link>
        <updated>2021-10-08T06:19:39.000Z</updated>
        <content type="html"><![CDATA[<p>JVM</p>
<p>jps：查看本机java进程信息。</p>
<p>jstack：打印线程的栈信息，制作线程dump文件。</p>
<p>jmap：打印内存映射，制作堆dump文件</p>
<p>jstat：性能监控工具</p>
<p>jhat：内存分析工具</p>
<p>jconsole：简易的可视化控制台</p>
<p>jvisualvm：功能强大的控制台</p>
<p>finally块一定会执行，无论是否try…catch。</p>
<p>finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p>
<p>finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p>
<p>MVC</p>
<p>MVC模式设计的web应用程序优点：可维护行强；可扩展性强；代码重复少</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633678163801.png" alt="" loading="lazy"></figure>
<p>Java中没有include关键字，导包用import</p>
<p>Java四种Import Declaration：</p>
<p>1.SingleTypeImportDeclaration，语法：import TypeName ;</p>
<p>2.TypeImportOnDemandDeclaretion，语法：import PackageOrTypeName . * ;</p>
<p>3.SingleStaticImportDeclaration，语法：import static TypeName . Identifier;</p>
<p>4.StaticImportOnDemandDeclaration，语法：import static TypeName . * ;</p>
<p>包装和基本类型不是同一个概念</p>
<p>long和double都占了64位（64bit）的存储空间</p>
<p>默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f</p>
<p>基本数据类型是没有静态方法的，但是基本数据类型的包装类却有</p>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
<p>​     通常，Java的异常(包括Exception和Error)分为 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions） 。<br>
​    可查异常（编译器要求必须处置的异常）：  正确的程序在运行中，很容易出现的、情理可容的异常状况 。 可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常 状况，就必须采取某种方式进行处理。</p>
<p>​	除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>​      不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p>
<p>​    运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p>非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<figure data-type="image" tabindex="2"><img src="https://clownjerome.github.io/post-images/1633678146485.png" alt="" loading="lazy"></figure>
<p>多态的作用是提高可重用性和扩展代码模块</p>
<p>封装的作用是隐藏细节</p>
<p>final</p>
<p>final类型的变量一定要初始化，因为final的变量不可更改</p>
<p>1，内部类声明在另一个类的内部，充当另一个类的成员变量，分为成员内部类，静态内部类，局部内部类，匿名内部类。</p>
<p>2，外部类访问内部类，必须创建内部类的对象</p>
<p>​    2.1，静态内部类：  外部类.内部类 引用名=new 外部类（）.内部类（）；</p>
<p>​    2.2，成员内部类：  外部类.内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>​      2.2.1，顶部引入内部类： import 包.外部类.内部类  内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>3，内部类访问外部类：因为内部类默认有外部类的引用，可以访问外部类的成员和方法，不需要创建对象</p>
<p>​    外部类.this.变量</p>
<p>4，一个源程序只能有一个public类与源文件同名，用public修饰的内部类可以不与源文件同名</p>
<p>5，外部类修饰符：public 包访问权限（默认）；成员内部类修饰符：public private protected 包访问权限</p>
<p>6，静态内部类可以有非静态成员，有静态成员的内部类一定是静态内部类，只可以访问外部的静态成员</p>
<p>7，局部内部类不可以有public，private，protected，static修饰符，只可以访问外部作用域的局部final变量</p>
<figure data-type="image" tabindex="3"><img src="https://clownjerome.github.io/post-images/1633678215749.png" alt="" loading="lazy"></figure>
<p>java中接口只能使用public修饰，接口内方法默认为public abstract</p>
<p>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；</p>
<p>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；</p>
<p>HttpSessionObjectListener：没有该接口API；</p>
<p>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；</p>
<p>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p>
<p>1、super()表示调用父类构造函数、this()调用自己的构造函数，而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况</p>
<p>2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中</p>
<p>3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。</p>
<p>局部变量参与运算前是必须要初始化</p>
<p>成员变量和静态变量是有默认值的</p>
<p>成员变量为int类型可以不初始化，默认值为0</p>
<p>局部变量为int类型必须初始化，没有默认值</p>
<p>int 类变量初始值0</p>
<p>boolean 类变量初始值false</p>
<p>char 类变量初始值'\u0000'</p>
<p>double 类变量初始值0.0</p>
<p>float 类变量初始值0.0f</p>
<p>long 类变量初始值0L</p>
<p>一旦在finally块中使用了return或throw语句，将会导致try块，catch块中的return，throw语句失效</p>
<p>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。</p>
<p>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</p>
<p>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</p>
<p>关键字volatile解决的下变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题</p>
<p>没有break，发生case穿透现象，程序会继续向下执行，直到遇到break或者结束switch语句的大括号为止。</p>
<p>String获取长度用的是length（）方法，而数组类型我们直接用属性length获取长度，所以String[]数组类型我们应该用length获取长度；2：总结来说，因为原字符串不包含分隔符，所以直接返回原字符串，分割出来只有一个空的字符串数组，所以结果是1.（注意，虽然原字符串为空，存到字符串数组为空，但是这个空也会算一个元素。）</p>
<p>并不是静态块最先初始化,而是静态域.</p>
<p>而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的</p>
<p>1.程序入口main方法要执行首先要加载类B</p>
<p>2.静态域：分为静态变量，静态方法，静态块。这里面涉及到的是静态变量和静态块，当执行到静态域时，按照静态域的顺序加载。并且静态域只在类的第一次加载时执行</p>
<p>3.每次new对象时，会执行一次构造块和构造方法，构造块总是在构造方法前执行（当然，第一次new时，会先执行静态域，静态域〉构造块〉构造方法）</p>
<p>​      注意：加载类时并不会调用构造块和构造方法，只有静态域会执行</p>
<p>public class B<br>
{<br>
public static B t1 = new B();<br>
public static B t2 = new B();<br>
{<br>
System.out.println(&quot;构造块&quot;);<br>
}<br>
static<br>
{<br>
System.out.println(&quot;静态块&quot;);<br>
}<br>
public static void main(String[] args)<br>
{<br>
B t = new B();<br>
}<br>
}</p>
<p>首先加载类B，执行静态域的第一个静态变量，static b1=new B，输出构造块和构造方法（空）。 这里不加载静态方法是因为执行了静态变量的初始化，意味着已经加载了B的静态域的一部分，这时候不能再加载另一个静态域了，否则属于重复加载 了（静态域必须当成一个整体来看待。否则加载会错乱）</p>
<p>wait(https://clownjerome.github.io/post-images/1633678250549.png)ject的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。</p>
<p>sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。</p>
<p>yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。</p>
<p>线程</p>
<p>JDK中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>尚未启动的线程处于这个状态。Thread thread = new Thread(new Runnable(){...});处于这个状态。</td>
<td>线程尚未启动的线程状态。当在程序中创建一个线程的时候Thread t = new Thread(Runnable);，线程处于NEW状态。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>可运行的线程处于这个状态。对应操作系统中的两种状态：ready和running，也就是说RUNNABLE状态既可以是可运行的，也可以是实际运行中的，有可能正在执行，也有可能没有正在执行。</td>
<td>可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统中的其他资源，比如处理器。也就是说， 这个状态就是可运行也可不运行的状态。注意Runnable ≠ Running。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞，进入synchronized修饰的方法或者代码块，等待监视器锁的线程处于这个状态。</td>
<td>进入synchronized修饰的方法或者代码块，等待监视器锁的阻塞线程的线程状态。比如，线程试图通过synchronized去获取监视器锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。等到获得了监视器锁之后会再次进入RUNNABLE状态。</td>
</tr>
<tr>
<td>WAITING</td>
<td>无限期等待另一个线程执行特定操作的线程处于这种状态。</td>
<td>调用以下方法之一，线程会处于等待状态：Object.wait()注意：括号内不带参数； Thread.join()注意：括号内不带参数； LockSupport.park();</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>正在等待另一个线程执行某个操作的线程在指定的等待时间内处于这种状态。</td>
<td>一个线程调用了以下方法之一（方法需要带具体的等待时间），会处于定时等待状态：Tread.sleep(long timeout) Object.wait(long timeout) Thread.join(long timeout) LockSupport.parkNanos() LockSupport.parkUntil()</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>已经退出的线程处于这个状态。</td>
<td>该线程已经执行完毕。执行完毕指的是线程正常执行完了run方法之后退出，也可以是遇到了未捕获的异常而退出。</td>
</tr>
</tbody>
</table>
<p>线程池</p>
<p>在JDK源码中，线程池（ThreadPoolExecutor）定义了五种状态：RUNNING、SHUTDOWN、STOP、TIDYING和TERMINATED。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>运行状态，可以添加新任务，也可以处理阻塞队列中的任务。</td>
<td>线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>待关闭状态，不再接受新的任务，会继续处理阻塞队列中的任务。</td>
<td>当线程池处于RUNNING状态时，调用shutdown()方法，线程池RUNNING状态转为SHUTDOWN状态。</td>
</tr>
<tr>
<td>STOP</td>
<td>停止状态，不再接受新的任务，不会执行阻塞队列中的任务，打断正在执行的任务。</td>
<td>当线程池处于RUNNING or SHUTDOWN时，调用shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN )状态转为STOP状态。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>整理状态，所有任务都处理完毕，workerCount为0，线程转到该状态将会运行terminated()钩子方法。</td>
<td>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN状态转为TIDYING状态。当线程池处于STOP状态，当线程池中执行的任务为空的时候，线程池有STOP状态转为TIDYING状态。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，terminated()方法执行完毕。</td>
<td>当线程池处于TIDYING状态，当执行完terminated()之后，就会由TIDYING状态转为TERMINATED状态。</td>
</tr>
</tbody>
</table>
<p>两个最基本的java回收算法：复制算法和标记清理算法</p>
<p>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<p>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出</p>
<p>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：新生代和年老代</p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记整理 ，局部采用复制</p>
<p>string是final修饰的，会将创建的变量放入字符串常量池，当再创建同样的字符串时，发现常量池中有则直接使用</p>
<p>a++访问a之后再对a进行加一操作</p>
<p>特殊变量super，提供了对父类的访问。<br>
可以使用super访问父类被子类隐藏的变量或覆盖的方法。<br>
每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>
构造是不能被继承的。</p>
<p>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p>
<p>类的加载顺序</p>
<p>(1) 父类静态对象和静态代码块</p>
<p>(2) 子类静态对象和静态代码块</p>
<p>(3) 父类非静态对象和非静态代码块</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类 非静态对象和非静态代码块</p>
<p>(6) 子类构造函数</p>
<p>join()的作用是：“等待该线程终止”</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。  //这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p>
<p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。//ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p>
<p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。//ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p>
<p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。//因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针。</p>
<figure data-type="image" tabindex="4"><img src="https://clownjerome.github.io/post-images/1633678114863.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://clownjerome.github.io/post-images/1633678122967.png" alt="" loading="lazy"></figure>
<p>没有模板不可能创建对象，创建对象必须先要定义类</p>
<p>对象中的数据域和方法取决于该对象的类，类里面有就有，没有就没有</p>
<p>数据域可以是基本类型变量，也可以是一个对象</p>
<p>数据域不一定是基本类型，也可以是引用类型</p>
<p>初始化块在构造器执行之前执行，类初始化阶段先执行最顶层父类的静态初始化块，依次向下执行，最后执行当前类的静态初始化块；创建对象时，先调用顶层父类的构造方法，依次向下执行，最后调用本类的构造方法。</p>
<p>实例方法：一个方法如果不加static关键字,那么这个方法是实例方法。意思就是他属于类的某个实例,通过这个实例调用它,对类的其他实例不产生影响.</p>
<p>类方法：也称静态方法。在方法前面加static关键字,就代表这个方法属于这个类本身,不属于他的任何实例,意思就是说,这个方法可以不通过实例调用,并且所有的实例都共享这一个方法,对方法的调用各个实例相互可见</p>
<p>start方法</p>
<p>​        用  start方法来启动线程，是真正实现了多线程，  通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p>
<p>run方法</p>
<p>​        run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p>
<p>instanceof可以用来判断某个实例变量是否属于某种类的类型，还可以判断某个类是否属于某个类的子类的类型。</p>
<p>&amp;与&amp;&amp;的异同点。</p>
<p>相同点：二者都表示与操作，当且仅当运算符两边的操作数都为true时，其结果才为true，否则为false。</p>
<p>不同点：在使用&amp;进行运算时，不论左边为true或者false，右边的表达式都会进行运算。如果使用&amp;&amp;进行运算时，当左边为false时，右边的表达式不会进行运算，因此&amp;&amp;被称作短路与。</p>
<p>|与||的异同点。</p>
<p>相同点：二者都表示或操作，当运算符两边的操作数任何一边的值为true时，其结果为true，当两边的值都为false时，其结果才为false。</p>
<p>不同点：同与操作类似，||表示短路或，当运算符左边的值为true时，右边的表达式不会进行运算。</p>
<p>&quot;?：&quot;: 三目运算符，三目运算符是右结合</p>
<p>静态内部类才可以声明静态方法</p>
<p>静态方法不可以使用非静态变量</p>
<p>抽象方法不可以有函数体</p>
<p>Thread实现了Runnable接口是一个类不是接口</p>
<p>实现多线程的三种方式，一种是继承Thread类使用此方式就不能继承其他的类了。还有两种是实现Runnable接口或者实现Callable接口</p>
<p>public 共有类；abstract 抽象类；final 不能被继承，没有子类；class 只能在包内使用的类</p>
<p>调用父类的无参构造用super（）</p>
<p>在 final 定义的方法里，不是必须要用 final 定义变量；final  定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化；final修饰方法，不能被子类重写，但是可以被重载；final 定义变量，可以用  static 也可以不用。</p>
<p>无论如何，Integer与new Integer不会相等。不会经历拆箱过程。<br>
两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。<br>
两个都是new出来的,都为false。<br>
int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。</p>
<p>父类静态代码块 &gt;子类静态代码块 &gt;父类非静态代码块 &gt; 父类构造函数 &gt; 子类非静态代码块 &gt; 子类构造函数。</p>
<p>Object默认9方法：getClass(),hashCode(),   equals(), clone(), toString(), notify(), notifyAll(),wait(), finalize()</p>
<figure data-type="image" tabindex="6"><img src="https://clownjerome.github.io/post-images/1633678074505.png" alt="" loading="lazy"></figure>
<p>身份证号表达式</p>
<p>isIDCard=/<em>^</em>[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/</p>
<p>isIDCard=/<em>^</em>[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$/</p>
<p>上三角：起始符号，上三角x表示以x开头<br>
美元符号：结束符号，x美元符号表示以x结尾<br>
[n-m]：表示从n到m的数字<br>
\d：表示数字，等同于[0-9]<br>
X{m}：表示由m个X字符构成，\d{4}表示4位数字</p>
<p>方法重载满足的条件</p>
<p>1.方法名必须相同；<br>
2.方法返回类型，修饰符可不同；<br>
3.参数类型或个数或顺序要不同。</p>
<p>String由final修饰，final不能被继承，不能被修改</p>
<p>String不可变的意义在于：</p>
<ol>
<li>字符串常量池的需要</li>
<li>允许String对象缓存HashCode</li>
<li>安全性</li>
</ol>
<p>StringBuffer是线程安全，StringBuilder线程不安全</p>
<p>速度：StringBuider&gt;StringBuffer&gt;String</p>
<p>一个.java文件中，可以有多个类，包括内部类和外部类。考虑到内部类的原因，一个.java文件中可以有多个public类。</p>
<p>但是对于外部类而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）。</p>
<p>Semaphore：类，控制某个资源可被同时访问的个数;</p>
<p>ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；</p>
<p>Future：接口，表示异步计算的结果；</p>
<p>CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</p>
<p>实例变量： 定义在类中的变量是类的成员变量，可以不进行初始化，  java  会自动进行初始化。（如果是引用类默认初始化为  null,  如果是基本类型，默认初始化为0）</p>
<p>局部变量：定义在方法中的变量，必须进行初始化，否则不通过编译。</p>
<p>类变量 ：（也叫作静态变量）是类中独立于方法之外的变量，用  static  修饰。</p>
<p>final 修饰的变量：也称为常量。</p>
<figure data-type="image" tabindex="7"><img src="https://clownjerome.github.io/post-images/1633678499329.png" alt="" loading="lazy"></figure>
<p>his的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；</p>
<p>super是调用父类的方法；</p>
<p>A(a)这种形式是在new一个类时使用。</p>
<p>Java三大注解分别是@Override@Deprecated@Suppresswarnings</p>
<p>@Override注解表名子类中覆盖了超类中的某个方法，如果写错了覆盖形式，编译器会报错</p>
<p>@Deprecated 表明不希望别人在以后使用这个类，方法，变量等等</p>
<p>@Suppresswarnings 达到抑制编译器产生警告的目的，但是不建议使用，因为后期编码人员看不懂编译器提示的警告，不能更好的选择更好的类去完成任务</p>
<p>Java中的关键字？</p>
<p>48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。</p>
<p>2个保留字（现在没用以后可能用到作为关键字）：goto、const。</p>
<p>3个特殊直接量：true、false、null。</p>
<p>Stack是栈， queue是对列；</p>
<p>栈是后进先出，对列是先进先出；</p>
<p>栈是出入从同一个位置；</p>
<p>对列是入从结构的一端进入，从另一端出队；</p>
<p>栈就像一个盒子，你把物体依次放入后，能先拿出来的只能是上面最后放进去的，下层的想要拿出需要将上层的先拿出，也就是先出栈；</p>
<p>对列是一个胡同，人们都进入胡同了，只有最前面的人从胡同出口出去，后面的人只有等前面的人走完后才能依次通过。</p>
<p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，先继承类再实现接口</p>
<p>抽象类可以有非抽象的方法，而接口中的方法都是抽象方法</p>
<p>java中类只能单继承，接口可以继承多个接口</p>
<p>抽象类必须有构造方法，接口一定没有构造方法</p>
<p>实例化一般指new一个对象，所以抽象类不能实例化</p>
<figure data-type="image" tabindex="8"><img src="https://clownjerome.github.io/post-images/1633677663238.png" alt="" loading="lazy"></figure>
<p>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。</p>
<p>Socket(InetAddress address ,int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。</p>
<p>socket和servletSocket的交互如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://clownjerome.github.io/post-images/1633677657618.png" alt="" loading="lazy"></figure>
<p>java.lang包包含</p>
<ul>
<li>包装类</li>
<li>String 类</li>
<li>Math 类   ——  包含函数</li>
<li>Class 类</li>
<li>Object 类</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以被任何类访问</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>可以被同一包中的所有类访问 可以被所有子类访问</td>
<td>子类没有在同一包中也可以访问</td>
</tr>
<tr>
<td>private</td>
<td>只能够被当前类的方法访问</td>
<td></td>
</tr>
<tr>
<td>缺省 无访问修饰符</td>
<td>可以被同一包中的所有类访问</td>
<td>如果子类没有在同一个包中，也不能访问</td>
</tr>
</tbody>
</table>
<p>不同类型数据间的优先关系如下：</p>
<p>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>HashSet子类依靠hashCode()，equals()方法区分重复元素。HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<p>intValue()是把Integer对象类型变成int的基础数据类型；<br>
parseInt()是把String  变成int的基础数据类型；<br>
Valueof()是把String  转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）</p>
<p>设置HTTP头标</p>
<p>response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); //三秒刷新页面一次</p>
<p>设置cookie</p>
<p>Cookie c1 = new<code></code>Cookie(&quot;username&quot;,&quot;only&quot;);response.addCookie(c1);</p>
<p>读取路径信息,request读取路径信息</p>
<p>从request获取各种路径总结 request.getRealPath(&quot;url&quot;); // 虚拟目录映射为实际目录request.getRealPath(&quot;./&quot;);  // 网页所在的目录request.getRealPath(&quot;../&quot;); // 网页所在目录的上一层目录request.getContextPath();  // 应用的web目录的名称</p>
<p>输出返回数据</p>
<p>HttpServleteResponse.getOutputStream().write();</p>
<p>System.arraycopy()：native方法+JVM手写函数，在JVM里预写好速度最快</p>
<p>clone()：native方法，但并未手写，需要JNI转换，速度其次</p>
<p>Arrays.copyof()：本质是调用1的方法</p>
<p>for()：全是深复制，并且不是封装方法，最慢情有可原</p>
<p>1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。而如果该关键字修饰的方法是static方法，则使用的锁就是class变量的锁；如果是修饰类方法，则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的，是在其子类实现的。所以，锁应该归其子类所有，所以，抽象方法也就不能用synchronized关键字修饰了；native这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？</p>
<p>2、接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用。而且protected访问修饰符也不能使用，因为接口可以让所有的类去实现（非继承），不只是其子类，但是要用public去修饰。接口可以去继承一个已有的接口。</p>
<p>类、方法、成员变量和局部变量的可用修饰符</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员访求</th>
<th>构造方法</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract（抽象的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>static（静态的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>public（公共的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>protected（受保护的）</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>private（私有的）</td>
<td>-</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>synchronized（同步的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>native（本地的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>transient（暂时的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>volatie（易失的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>final（不要改变的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>类 修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从其他类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abstract</td>
<td>本类不能被实例化</td>
</tr>
<tr>
<td>Final</td>
<td>不能再声明子类</td>
</tr>
</tbody>
</table>
<p>构造函数修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从自己的类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能在本类中访问</td>
</tr>
</tbody>
</table>
<p>域\成员变量修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>Static</td>
<td>对该类的所有实例只能有一个域值存在</td>
</tr>
<tr>
<td>transient</td>
<td>不是一个对象持久状态的一部份</td>
</tr>
<tr>
<td>Volatile</td>
<td>可以被异步的线程所修改</td>
</tr>
<tr>
<td>final</td>
<td>必须对它赋予初值并且不能修改它</td>
</tr>
</tbody>
</table>
<p>局部变量 修饰符</p>
<table>
<thead>
<tr>
<th>final</th>
<th>必须对它赋予初值并且不能修改它</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>方法修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问它</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类及其子类中访问它</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>abstract</td>
<td>没有方法体，属于一个抽象类</td>
</tr>
<tr>
<td>final</td>
<td>子类不能覆盖它</td>
</tr>
<tr>
<td>static</td>
<td>被绑定于类本身而不是类的实例</td>
</tr>
<tr>
<td>native</td>
<td>该方法由其他编程语言实现</td>
</tr>
<tr>
<td>asnchronized</td>
<td>在一个线程调用它之前必须先给它加</td>
</tr>
</tbody>
</table>
<p>类的修饰符整合</p>
<p>类</p>
<p>类的修饰符：</p>
<p>Public:可以在其他任何类中使用，默认为统一包下的任意类。</p>
<p>Abstract:抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。</p>
<p>Final:不能被继承。</p>
<p>变量</p>
<p>变量修饰符：</p>
<p>一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。</p>
<p>可访问修饰符：</p>
<p>static**：**类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。</p>
<p>final**：**常量。</p>
<p>volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。</p>
<p>实例变量：和类变量对应，即每个对象都拥有各自独立的实例变量。</p>
<p>方法：（和变量对象分为实例方法和类方法，并用有无static修饰区别）</p>
<p>类方法：使用static关键字说明的方法</p>
<p>1.第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。</p>
<p>2.类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。</p>
<p>实例方法：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。</p>
<p>方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）</p>
<p>方法的返回类型：若无返回类型，则声明为void.</p>
<p>方法中的变量作用域：</p>
<p>成员变量：整个类。</p>
<p>局部变量：定义起到方法块结束为止。</p>
<p>方法参数：整个方法或者构造方法。</p>
<p>异常处理参数：参数传递给异常处理方法。</p>
<p>构造方法：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。</p>
<p>静态初始化器：格式：static{&lt;赋值语句组&gt;}</p>
<p>静态初始化器与构造方法的区别：</p>
<table>
<thead>
<tr>
<th>静态初始化器</th>
<th>构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>对类的静态域初始化</td>
<td>对新建的对象初始化</td>
</tr>
<tr>
<td>类进入内存后，系统调用执行</td>
<td>执行new后自动执行</td>
</tr>
<tr>
<td>属特殊语句（仅执行一次）</td>
<td>属特殊方法</td>
</tr>
</tbody>
</table>
<p>方法的修饰符：</p>
<p>抽象方法：用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。</p>
<p>类方法：静态方法，用static修饰，</p>
<p>调用时，使用类名作为前缀，而不是类的某个实例对象名</p>
<p>不能被单独对象拥有，属于整个类共享。</p>
<p>不能处理成员变量。</p>
<p>最终方法：用final修饰，不能被子类重新定义的方法。</p>
<p>本地方法：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。</p>
<p>Java访问控制符的含义和使用情况</p>
<table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>java自动装箱，对于Integer和Double的自动装箱，只能装对应的数据类型，不对应就会报错。java中100默认是int型,而不是byte，short和long;100.0默认是double，而不是float。</p>
<p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p>
<p>AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。<br>
AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象 ，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。<br>
核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉， AOP只是OOP的补充，无替代关系。</p>
<figure data-type="image" tabindex="10"><img src="https://clownjerome.github.io/post-images/1633677626834.png" alt="" loading="lazy"></figure>
<p>Java中的四类八种基本数据类型</p>
<p>第一类：整数类型  byte short int long</p>
<p>第二类：浮点型  float double</p>
<p>第三类：逻辑型   boolean(它只有两个值可取true false)</p>
<p>第四类：字符型  char</p>
<p>Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度</p>
<p>start()方法是启动一个线程，此时的线程处于就绪状态，但并不一定就会执行，还需要等待CPU的调度。<br>
run()方法才是线程获得CPU时间，开始执行的点。</p>
<p>实现线程的方法有三种：<br>
第一种：继承Thread类覆盖父类的run()方法   创建子类对象 然后  对象.start();执行线程 run()方法执行<br>
第二种：实现Runnable接口 覆盖接口的run()方法   创建线程对象将子类传入，然后线程对象.start();启动线程  run()方法执行<br>
第三种：实现Callable接口  类似于Runnable接口<br>
Callable与Runnable接口的区别是：<br>
①Callable规定的方法是call()，而Runnable规定的方法是run().<br>
②Callable的任务执行后可返回值，而Runnable的任务是不能返回值的<br>
③call()方法可抛出异常，而run()方法是不能抛出异常的。<br>
④运行Callable任务可拿到一个Future对象，Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成,并检索计算的结果。通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果</p>
<p>throws 和 throw：</p>
<p>throws出现在方法头，表示可能会出现异常</p>
<p>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p>
<p>inputstream的close方法用来关闭流</p>
<p>skip()用来跳过一些字节</p>
<p>mark（）用来标记流</p>
<p>reset（）复位流</p>
<p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p>
<p>补充：</p>
<p>​          什么是类加载器？</p>
<p>​    把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>有哪些类加载器，分别加载哪些类</p>
<p>​    类加载器按照层次，从顶层到底层，分为以下三种：</p>
<p>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类</p>
<p>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p>
<p>(3)    应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p>
<p>​          双亲委派模型</p>
<p>​    我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为类加载器的双亲委派模型，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。</p>
<p>​          双亲委托模型的工作原理</p>
<p>​    是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p>
<p>​          使用双亲委派模型好处？（原因）</p>
<p>​    第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>​    第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器</p>
<p>（1）父类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（2）子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（3）父类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（4）执行父类构造方法。</p>
<p>（5）子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（6）执行子类构造方法</p>
<p>Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点。</p>
<p>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</p>
<p>(1)加载：Servlet容器（Tomcat）通过类加载器加载servlet文件（.class）</p>
<p>(2)创建：通过调用servlet构造函数创建一个servlet对象</p>
<p>(3)初始化：调用init方法初始化</p>
<p>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求</p>
<p>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>
<p>servlet是由Servlet容器负责加载Servlet类，创建Servlet对象并实例化，然后调用Servlet的init方法，进行初始化，之后调用Service方法。实例化和初始化不同。先实例化，再初始化。</p>
<p>再说一下ServletConfig和ServletContext</p>
<p>Jsp/Servlet容器初始化一个Servlet类型的对象时，会为这个Servlet对象创建一个ServletConfig对象。在ServletConfig对象中包含了Servlet的初始化参数信息。</p>
<p>ServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Webapp时，会为它创建一个ServletContext对象，即servlet上下文环境。每个webapp都有唯一的ServletContext对象。同一个webapp的所有servlet对象共享一个ServeltContext，servlet对象可以通过ServletContext来访问容器中的各种资源。</p>
<p>从作用范围来说，ServletConfig作用于某个特定的Servlet，即从该Servlet实例化，那么就开始有效，但是该Servlet之外的其他Servlet不能访问；ServletContext作用于某个webapp，即在一个webapp中相当于一个全局对象，在Servlet容器启动时就已经加载，对于不同的webapp，有不同的ServletContext。</p>
<p>最后，说明一下参数的获取。访问ServletConfig参数，取得ServletConfig对象后，调用getInitParameter()方法;访问ServletContext对象，只要调用现有的ServletConfig对象的getServletContext()即可，然后同样调用getInitParamter()方法就能获取参数。</p>
<figure data-type="image" tabindex="11"><img src="https://clownjerome.github.io/post-images/1633677569488.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://clownjerome.github.io/post-images/1633677561877.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://clownjerome.github.io/post/hello-world/</id>
        <link href="https://clownjerome.github.io/post/hello-world/">
        </link>
        <updated>2021-09-26T11:44:59.000Z</updated>
        <content type="html"><![CDATA[<CENTER><FONT face=隶书 color=red size=15>
<MARQUEE direction=up behavior=alternate width=60 height=120>我</MARQUEE>
<FONT color=yellow>
<MARQUEE direction=up behavior=alternate width=60 height=80>的</MARQUEE>
<FONT color=brown>
<MARQUEE direction=up behavior=alternate width=60 height=120>第</MARQUEE>
<FONT color=green>
<MARQUEE direction=up behavior=alternate width=60 height=80>一</MARQUEE>
<FONT color=orange>
<MARQUEE direction=up behavior=alternate width=60 height=120>篇</MARQUEE>
<FONT color=yellow>
<MARQUEE direction=up behavior=alternate width=60 height=80>文</MARQUEE>
<FONT color=orange>
<MARQUEE direction=up behavior=alternate width=60 height=120>章</MARQUEE>
</FONT>
</B>
</MARQUEE>
</FONT>
</CENTER>
</FONT>
</FONT>
</FONT>
</FONT>
</FONT>
</FONT>
<P style="text-align:center"><FONT color=#ff0000>希望在以</FONT><FONT color=#d52a00>后的日子</FONT><FONT color=#ab5400>里努力更</FONT><FONT color=#817e00>改及美化</FONT><FONT color=#57a800>我的博</FONT><FONT color=#2dd200>客世界</FONT>🥂</P>
<P style="text-align:center"><FONT face="楷体" >文章千古事，得失寸心知。</BR>
作者皆殊列，名声岂浪垂。</BR>
骚人嗟不见，汉道盛于斯。</BR>
前辈飞腾入，馀波绮丽为。</BR>
后贤兼旧列，历代各清规。</BR>
法自儒家有，心从弱岁疲。</BR>
永怀江左逸，多病邺中奇。</BR>
騄骥皆良马，骐驎带好儿。</BR>
车轮徒已斫，堂构惜仍亏。</BR>
漫作潜夫论，虚传幼妇碑。</BR>
缘情慰漂荡，抱疾屡迁移。</BR>
经济惭长策，飞栖假一枝。</BR>
尘沙傍蜂虿，江峡绕蛟螭。</BR>
萧瑟唐虞远，联翩楚汉危。</BR>
圣朝兼盗贼，异俗更喧卑。</BR>
郁郁星辰剑，苍苍云雨池。</BR>
两都开幕府，万宇插军麾。</BR>
南海残铜柱，东风避月支。</BR>
音书恨乌鹊，号怒怪熊罴。</BR>
稼穑分诗兴，柴荆学土宜。</BR>
故山迷白阁，秋水隐黄陂。</BR>
不敢要佳句，愁来赋别离。</BR>
——杜甫·偶题</FOUNT></P>
]]></content>
    </entry>
</feed>
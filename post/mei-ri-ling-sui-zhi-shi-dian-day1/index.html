<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>每日零碎知识点Day1 | 陈思羽</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://clownjerome.github.io/favicon.ico?v=1635518576895">
<link rel="stylesheet" href="https://clownjerome.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="JVM
jps：查看本机java进程信息。
jstack：打印线程的栈信息，制作线程dump文件。
jmap：打印内存映射，制作堆dump文件
jstat：性能监控工具
jhat：内存分析工具
jconsole：简易的可视化控制台
jvis..." />
    <meta name="keywords" content="琐碎知识点" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://clownjerome.github.io">
        <img src="https://clownjerome.github.io/images/avatar.png?v=1635518576895" class="site-logo">
        <h1 class="site-title">陈思羽</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      天道酬勤
    </div>
    <div class="site-footer">
      欢迎来到陈思羽的个人博客 | <a class="rss" href="https://clownjerome.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">每日零碎知识点Day1</h2>
            <div class="post-date">2021-10-08</div>
            
            <div class="post-content" v-pre>
              <p>JVM</p>
<p>jps：查看本机java进程信息。</p>
<p>jstack：打印线程的栈信息，制作线程dump文件。</p>
<p>jmap：打印内存映射，制作堆dump文件</p>
<p>jstat：性能监控工具</p>
<p>jhat：内存分析工具</p>
<p>jconsole：简易的可视化控制台</p>
<p>jvisualvm：功能强大的控制台</p>
<p>finally块一定会执行，无论是否try…catch。</p>
<p>finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p>
<p>finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p>
<p>MVC</p>
<p>MVC模式设计的web应用程序优点：可维护行强；可扩展性强；代码重复少</p>
<figure data-type="image" tabindex="1"><img src="https://clownjerome.github.io/post-images/1633678163801.png" alt="" loading="lazy"></figure>
<p>Java中没有include关键字，导包用import</p>
<p>Java四种Import Declaration：</p>
<p>1.SingleTypeImportDeclaration，语法：import TypeName ;</p>
<p>2.TypeImportOnDemandDeclaretion，语法：import PackageOrTypeName . * ;</p>
<p>3.SingleStaticImportDeclaration，语法：import static TypeName . Identifier;</p>
<p>4.StaticImportOnDemandDeclaration，语法：import static TypeName . * ;</p>
<p>包装和基本类型不是同一个概念</p>
<p>long和double都占了64位（64bit）的存储空间</p>
<p>默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f</p>
<p>基本数据类型是没有静态方法的，但是基本数据类型的包装类却有</p>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
<p>​     通常，Java的异常(包括Exception和Error)分为 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions） 。<br>
​    可查异常（编译器要求必须处置的异常）：  正确的程序在运行中，很容易出现的、情理可容的异常状况 。 可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常 状况，就必须采取某种方式进行处理。</p>
<p>​	除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>​      不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p>
<p>​    运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p>非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<figure data-type="image" tabindex="2"><img src="https://clownjerome.github.io/post-images/1633678146485.png" alt="" loading="lazy"></figure>
<p>多态的作用是提高可重用性和扩展代码模块</p>
<p>封装的作用是隐藏细节</p>
<p>final</p>
<p>final类型的变量一定要初始化，因为final的变量不可更改</p>
<p>1，内部类声明在另一个类的内部，充当另一个类的成员变量，分为成员内部类，静态内部类，局部内部类，匿名内部类。</p>
<p>2，外部类访问内部类，必须创建内部类的对象</p>
<p>​    2.1，静态内部类：  外部类.内部类 引用名=new 外部类（）.内部类（）；</p>
<p>​    2.2，成员内部类：  外部类.内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>​      2.2.1，顶部引入内部类： import 包.外部类.内部类  内部类 引用名=new 外部类（）.new 内部类（）；</p>
<p>3，内部类访问外部类：因为内部类默认有外部类的引用，可以访问外部类的成员和方法，不需要创建对象</p>
<p>​    外部类.this.变量</p>
<p>4，一个源程序只能有一个public类与源文件同名，用public修饰的内部类可以不与源文件同名</p>
<p>5，外部类修饰符：public 包访问权限（默认）；成员内部类修饰符：public private protected 包访问权限</p>
<p>6，静态内部类可以有非静态成员，有静态成员的内部类一定是静态内部类，只可以访问外部的静态成员</p>
<p>7，局部内部类不可以有public，private，protected，static修饰符，只可以访问外部作用域的局部final变量</p>
<figure data-type="image" tabindex="3"><img src="https://clownjerome.github.io/post-images/1633678215749.png" alt="" loading="lazy"></figure>
<p>java中接口只能使用public修饰，接口内方法默认为public abstract</p>
<p>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；</p>
<p>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；</p>
<p>HttpSessionObjectListener：没有该接口API；</p>
<p>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；</p>
<p>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p>
<p>1、super()表示调用父类构造函数、this()调用自己的构造函数，而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况</p>
<p>2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中</p>
<p>3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。</p>
<p>局部变量参与运算前是必须要初始化</p>
<p>成员变量和静态变量是有默认值的</p>
<p>成员变量为int类型可以不初始化，默认值为0</p>
<p>局部变量为int类型必须初始化，没有默认值</p>
<p>int 类变量初始值0</p>
<p>boolean 类变量初始值false</p>
<p>char 类变量初始值'\u0000'</p>
<p>double 类变量初始值0.0</p>
<p>float 类变量初始值0.0f</p>
<p>long 类变量初始值0L</p>
<p>一旦在finally块中使用了return或throw语句，将会导致try块，catch块中的return，throw语句失效</p>
<p>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。</p>
<p>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</p>
<p>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</p>
<p>关键字volatile解决的下变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题</p>
<p>没有break，发生case穿透现象，程序会继续向下执行，直到遇到break或者结束switch语句的大括号为止。</p>
<p>String获取长度用的是length（）方法，而数组类型我们直接用属性length获取长度，所以String[]数组类型我们应该用length获取长度；2：总结来说，因为原字符串不包含分隔符，所以直接返回原字符串，分割出来只有一个空的字符串数组，所以结果是1.（注意，虽然原字符串为空，存到字符串数组为空，但是这个空也会算一个元素。）</p>
<p>并不是静态块最先初始化,而是静态域.</p>
<p>而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的</p>
<p>1.程序入口main方法要执行首先要加载类B</p>
<p>2.静态域：分为静态变量，静态方法，静态块。这里面涉及到的是静态变量和静态块，当执行到静态域时，按照静态域的顺序加载。并且静态域只在类的第一次加载时执行</p>
<p>3.每次new对象时，会执行一次构造块和构造方法，构造块总是在构造方法前执行（当然，第一次new时，会先执行静态域，静态域〉构造块〉构造方法）</p>
<p>​      注意：加载类时并不会调用构造块和构造方法，只有静态域会执行</p>
<p>public class B<br>
{<br>
public static B t1 = new B();<br>
public static B t2 = new B();<br>
{<br>
System.out.println(&quot;构造块&quot;);<br>
}<br>
static<br>
{<br>
System.out.println(&quot;静态块&quot;);<br>
}<br>
public static void main(String[] args)<br>
{<br>
B t = new B();<br>
}<br>
}</p>
<p>首先加载类B，执行静态域的第一个静态变量，static b1=new B，输出构造块和构造方法（空）。 这里不加载静态方法是因为执行了静态变量的初始化，意味着已经加载了B的静态域的一部分，这时候不能再加载另一个静态域了，否则属于重复加载 了（静态域必须当成一个整体来看待。否则加载会错乱）</p>
<p>wait(https://clownjerome.github.io/post-images/1633678250549.png)ject的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。</p>
<p>sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。</p>
<p>yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。</p>
<p>线程</p>
<p>JDK中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>尚未启动的线程处于这个状态。Thread thread = new Thread(new Runnable(){...});处于这个状态。</td>
<td>线程尚未启动的线程状态。当在程序中创建一个线程的时候Thread t = new Thread(Runnable);，线程处于NEW状态。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>可运行的线程处于这个状态。对应操作系统中的两种状态：ready和running，也就是说RUNNABLE状态既可以是可运行的，也可以是实际运行中的，有可能正在执行，也有可能没有正在执行。</td>
<td>可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待操作系统中的其他资源，比如处理器。也就是说， 这个状态就是可运行也可不运行的状态。注意Runnable ≠ Running。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞，进入synchronized修饰的方法或者代码块，等待监视器锁的线程处于这个状态。</td>
<td>进入synchronized修饰的方法或者代码块，等待监视器锁的阻塞线程的线程状态。比如，线程试图通过synchronized去获取监视器锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。等到获得了监视器锁之后会再次进入RUNNABLE状态。</td>
</tr>
<tr>
<td>WAITING</td>
<td>无限期等待另一个线程执行特定操作的线程处于这种状态。</td>
<td>调用以下方法之一，线程会处于等待状态：Object.wait()注意：括号内不带参数； Thread.join()注意：括号内不带参数； LockSupport.park();</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>正在等待另一个线程执行某个操作的线程在指定的等待时间内处于这种状态。</td>
<td>一个线程调用了以下方法之一（方法需要带具体的等待时间），会处于定时等待状态：Tread.sleep(long timeout) Object.wait(long timeout) Thread.join(long timeout) LockSupport.parkNanos() LockSupport.parkUntil()</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>已经退出的线程处于这个状态。</td>
<td>该线程已经执行完毕。执行完毕指的是线程正常执行完了run方法之后退出，也可以是遇到了未捕获的异常而退出。</td>
</tr>
</tbody>
</table>
<p>线程池</p>
<p>在JDK源码中，线程池（ThreadPoolExecutor）定义了五种状态：RUNNING、SHUTDOWN、STOP、TIDYING和TERMINATED。</p>
<table>
<thead>
<tr>
<th></th>
<th>状态说明</th>
<th>状态转移</th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>运行状态，可以添加新任务，也可以处理阻塞队列中的任务。</td>
<td>线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>待关闭状态，不再接受新的任务，会继续处理阻塞队列中的任务。</td>
<td>当线程池处于RUNNING状态时，调用shutdown()方法，线程池RUNNING状态转为SHUTDOWN状态。</td>
</tr>
<tr>
<td>STOP</td>
<td>停止状态，不再接受新的任务，不会执行阻塞队列中的任务，打断正在执行的任务。</td>
<td>当线程池处于RUNNING or SHUTDOWN时，调用shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN )状态转为STOP状态。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>整理状态，所有任务都处理完毕，workerCount为0，线程转到该状态将会运行terminated()钩子方法。</td>
<td>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN状态转为TIDYING状态。当线程池处于STOP状态，当线程池中执行的任务为空的时候，线程池有STOP状态转为TIDYING状态。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，terminated()方法执行完毕。</td>
<td>当线程池处于TIDYING状态，当执行完terminated()之后，就会由TIDYING状态转为TERMINATED状态。</td>
</tr>
</tbody>
</table>
<p>两个最基本的java回收算法：复制算法和标记清理算法</p>
<p>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<p>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出</p>
<p>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：新生代和年老代</p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记整理 ，局部采用复制</p>
<p>string是final修饰的，会将创建的变量放入字符串常量池，当再创建同样的字符串时，发现常量池中有则直接使用</p>
<p>a++访问a之后再对a进行加一操作</p>
<p>特殊变量super，提供了对父类的访问。<br>
可以使用super访问父类被子类隐藏的变量或覆盖的方法。<br>
每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>
构造是不能被继承的。</p>
<p>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p>
<p>类的加载顺序</p>
<p>(1) 父类静态对象和静态代码块</p>
<p>(2) 子类静态对象和静态代码块</p>
<p>(3) 父类非静态对象和非静态代码块</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类 非静态对象和非静态代码块</p>
<p>(6) 子类构造函数</p>
<p>join()的作用是：“等待该线程终止”</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。  //这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p>
<p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。//ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p>
<p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。//ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p>
<p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。//因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针。</p>
<figure data-type="image" tabindex="4"><img src="https://clownjerome.github.io/post-images/1633678114863.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://clownjerome.github.io/post-images/1633678122967.png" alt="" loading="lazy"></figure>
<p>没有模板不可能创建对象，创建对象必须先要定义类</p>
<p>对象中的数据域和方法取决于该对象的类，类里面有就有，没有就没有</p>
<p>数据域可以是基本类型变量，也可以是一个对象</p>
<p>数据域不一定是基本类型，也可以是引用类型</p>
<p>初始化块在构造器执行之前执行，类初始化阶段先执行最顶层父类的静态初始化块，依次向下执行，最后执行当前类的静态初始化块；创建对象时，先调用顶层父类的构造方法，依次向下执行，最后调用本类的构造方法。</p>
<p>实例方法：一个方法如果不加static关键字,那么这个方法是实例方法。意思就是他属于类的某个实例,通过这个实例调用它,对类的其他实例不产生影响.</p>
<p>类方法：也称静态方法。在方法前面加static关键字,就代表这个方法属于这个类本身,不属于他的任何实例,意思就是说,这个方法可以不通过实例调用,并且所有的实例都共享这一个方法,对方法的调用各个实例相互可见</p>
<p>start方法</p>
<p>​        用  start方法来启动线程，是真正实现了多线程，  通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p>
<p>run方法</p>
<p>​        run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p>
<p>instanceof可以用来判断某个实例变量是否属于某种类的类型，还可以判断某个类是否属于某个类的子类的类型。</p>
<p>&amp;与&amp;&amp;的异同点。</p>
<p>相同点：二者都表示与操作，当且仅当运算符两边的操作数都为true时，其结果才为true，否则为false。</p>
<p>不同点：在使用&amp;进行运算时，不论左边为true或者false，右边的表达式都会进行运算。如果使用&amp;&amp;进行运算时，当左边为false时，右边的表达式不会进行运算，因此&amp;&amp;被称作短路与。</p>
<p>|与||的异同点。</p>
<p>相同点：二者都表示或操作，当运算符两边的操作数任何一边的值为true时，其结果为true，当两边的值都为false时，其结果才为false。</p>
<p>不同点：同与操作类似，||表示短路或，当运算符左边的值为true时，右边的表达式不会进行运算。</p>
<p>&quot;?：&quot;: 三目运算符，三目运算符是右结合</p>
<p>静态内部类才可以声明静态方法</p>
<p>静态方法不可以使用非静态变量</p>
<p>抽象方法不可以有函数体</p>
<p>Thread实现了Runnable接口是一个类不是接口</p>
<p>实现多线程的三种方式，一种是继承Thread类使用此方式就不能继承其他的类了。还有两种是实现Runnable接口或者实现Callable接口</p>
<p>public 共有类；abstract 抽象类；final 不能被继承，没有子类；class 只能在包内使用的类</p>
<p>调用父类的无参构造用super（）</p>
<p>在 final 定义的方法里，不是必须要用 final 定义变量；final  定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化；final修饰方法，不能被子类重写，但是可以被重载；final 定义变量，可以用  static 也可以不用。</p>
<p>无论如何，Integer与new Integer不会相等。不会经历拆箱过程。<br>
两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。<br>
两个都是new出来的,都为false。<br>
int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。</p>
<p>父类静态代码块 &gt;子类静态代码块 &gt;父类非静态代码块 &gt; 父类构造函数 &gt; 子类非静态代码块 &gt; 子类构造函数。</p>
<p>Object默认9方法：getClass(),hashCode(),   equals(), clone(), toString(), notify(), notifyAll(),wait(), finalize()</p>
<figure data-type="image" tabindex="6"><img src="https://clownjerome.github.io/post-images/1633678074505.png" alt="" loading="lazy"></figure>
<p>身份证号表达式</p>
<p><code>isIDCard=/^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/</code></p>
<p><code>isIDCard=/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$/</code></p>
<p><code>^：起始符号，^x表示以x开头</code><br>
<code>$：结束符号，x$表示以x结尾</code><br>
[n-m]：表示从n到m的数字<br>
\d：表示数字，等同于[0-9]<br>
X{m}：表示由m个X字符构成，\d{4}表示4位数字</p>
<p>方法重载满足的条件</p>
<p>1.方法名必须相同；<br>
2.方法返回类型，修饰符可不同；<br>
3.参数类型或个数或顺序要不同。</p>
<p>String由final修饰，final不能被继承，不能被修改</p>
<p>String不可变的意义在于：</p>
<ol>
<li>字符串常量池的需要</li>
<li>允许String对象缓存HashCode</li>
<li>安全性</li>
</ol>
<p>StringBuffer是线程安全，StringBuilder线程不安全</p>
<p>速度：StringBuider&gt;StringBuffer&gt;String</p>
<p>一个.java文件中，可以有多个类，包括内部类和外部类。考虑到内部类的原因，一个.java文件中可以有多个public类。</p>
<p>但是对于外部类而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）。</p>
<p>Semaphore：类，控制某个资源可被同时访问的个数;</p>
<p>ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；</p>
<p>Future：接口，表示异步计算的结果；</p>
<p>CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</p>
<p>实例变量： 定义在类中的变量是类的成员变量，可以不进行初始化，  java  会自动进行初始化。（如果是引用类默认初始化为  null,  如果是基本类型，默认初始化为0）</p>
<p>局部变量：定义在方法中的变量，必须进行初始化，否则不通过编译。</p>
<p>类变量 ：（也叫作静态变量）是类中独立于方法之外的变量，用  static  修饰。</p>
<p>final 修饰的变量：也称为常量。</p>
<figure data-type="image" tabindex="7"><img src="https://clownjerome.github.io/post-images/1633678499329.png" alt="" loading="lazy"></figure>
<p>his的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；</p>
<p>super是调用父类的方法；</p>
<p>A(a)这种形式是在new一个类时使用。</p>
<p>Java三大注解分别是@Override@Deprecated@Suppresswarnings</p>
<p>@Override注解表名子类中覆盖了超类中的某个方法，如果写错了覆盖形式，编译器会报错</p>
<p>@Deprecated 表明不希望别人在以后使用这个类，方法，变量等等</p>
<p>@Suppresswarnings 达到抑制编译器产生警告的目的，但是不建议使用，因为后期编码人员看不懂编译器提示的警告，不能更好的选择更好的类去完成任务</p>
<p>Java中的关键字？</p>
<p>48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。</p>
<p>2个保留字（现在没用以后可能用到作为关键字）：goto、const。</p>
<p>3个特殊直接量：true、false、null。</p>
<p>Stack是栈， queue是对列；</p>
<p>栈是后进先出，对列是先进先出；</p>
<p>栈是出入从同一个位置；</p>
<p>对列是入从结构的一端进入，从另一端出队；</p>
<p>栈就像一个盒子，你把物体依次放入后，能先拿出来的只能是上面最后放进去的，下层的想要拿出需要将上层的先拿出，也就是先出栈；</p>
<p>对列是一个胡同，人们都进入胡同了，只有最前面的人从胡同出口出去，后面的人只有等前面的人走完后才能依次通过。</p>
<p>类实现多个接口的时候，只需要一个implements，多个接口通过逗号进行隔开，先继承类再实现接口</p>
<p>抽象类可以有非抽象的方法，而接口中的方法都是抽象方法</p>
<p>java中类只能单继承，接口可以继承多个接口</p>
<p>抽象类必须有构造方法，接口一定没有构造方法</p>
<p>实例化一般指new一个对象，所以抽象类不能实例化</p>
<figure data-type="image" tabindex="8"><img src="https://clownjerome.github.io/post-images/1633677663238.png" alt="" loading="lazy"></figure>
<p>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。</p>
<p>Socket(InetAddress address ,int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。</p>
<p>socket和servletSocket的交互如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://clownjerome.github.io/post-images/1633677657618.png" alt="" loading="lazy"></figure>
<p>java.lang包包含</p>
<ul>
<li>包装类</li>
<li>String 类</li>
<li>Math 类   ——  包含函数</li>
<li>Class 类</li>
<li>Object 类</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以被任何类访问</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>可以被同一包中的所有类访问 可以被所有子类访问</td>
<td>子类没有在同一包中也可以访问</td>
</tr>
<tr>
<td>private</td>
<td>只能够被当前类的方法访问</td>
<td></td>
</tr>
<tr>
<td>缺省 无访问修饰符</td>
<td>可以被同一包中的所有类访问</td>
<td>如果子类没有在同一个包中，也不能访问</td>
</tr>
</tbody>
</table>
<p>不同类型数据间的优先关系如下：</p>
<p>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>HashSet子类依靠hashCode()，equals()方法区分重复元素。HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<p>intValue()是把Integer对象类型变成int的基础数据类型；<br>
parseInt()是把String  变成int的基础数据类型；<br>
Valueof()是把String  转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）</p>
<p>设置HTTP头标</p>
<p>response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); //三秒刷新页面一次</p>
<p>设置cookie</p>
<p>Cookie c1 = new<code></code>Cookie(&quot;username&quot;,&quot;only&quot;);response.addCookie(c1);</p>
<p>读取路径信息,request读取路径信息</p>
<p>从request获取各种路径总结 request.getRealPath(&quot;url&quot;); // 虚拟目录映射为实际目录request.getRealPath(&quot;./&quot;);  // 网页所在的目录request.getRealPath(&quot;../&quot;); // 网页所在目录的上一层目录request.getContextPath();  // 应用的web目录的名称</p>
<p>输出返回数据</p>
<p>HttpServleteResponse.getOutputStream().write();</p>
<p>System.arraycopy()：native方法+JVM手写函数，在JVM里预写好速度最快</p>
<p>clone()：native方法，但并未手写，需要JNI转换，速度其次</p>
<p>Arrays.copyof()：本质是调用1的方法</p>
<p>for()：全是深复制，并且不是封装方法，最慢情有可原</p>
<p>1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。而如果该关键字修饰的方法是static方法，则使用的锁就是class变量的锁；如果是修饰类方法，则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的，是在其子类实现的。所以，锁应该归其子类所有，所以，抽象方法也就不能用synchronized关键字修饰了；native这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？</p>
<p>2、接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用。而且protected访问修饰符也不能使用，因为接口可以让所有的类去实现（非继承），不只是其子类，但是要用public去修饰。接口可以去继承一个已有的接口。</p>
<p>类、方法、成员变量和局部变量的可用修饰符</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员访求</th>
<th>构造方法</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract（抽象的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>static（静态的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>public（公共的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>protected（受保护的）</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>private（私有的）</td>
<td>-</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>synchronized（同步的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>native（本地的）</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>transient（暂时的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>volatie（易失的）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>final（不要改变的）</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>类 修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从其他类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abstract</td>
<td>本类不能被实例化</td>
</tr>
<tr>
<td>Final</td>
<td>不能再声明子类</td>
</tr>
</tbody>
</table>
<p>构造函数修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从自己的类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能在本类中访问</td>
</tr>
</tbody>
</table>
<p>域\成员变量修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类和它的子类中访问</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>Static</td>
<td>对该类的所有实例只能有一个域值存在</td>
</tr>
<tr>
<td>transient</td>
<td>不是一个对象持久状态的一部份</td>
</tr>
<tr>
<td>Volatile</td>
<td>可以被异步的线程所修改</td>
</tr>
<tr>
<td>final</td>
<td>必须对它赋予初值并且不能修改它</td>
</tr>
</tbody>
</table>
<p>局部变量 修饰符</p>
<table>
<thead>
<tr>
<th>final</th>
<th>必须对它赋予初值并且不能修改它</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>方法修饰符</p>
<table>
<thead>
<tr>
<th>Public</th>
<th>可以从所有的类中访问它</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protected</td>
<td>只能从本类及其子类中访问它</td>
</tr>
<tr>
<td>Private</td>
<td>只能从本类中访问它</td>
</tr>
<tr>
<td>abstract</td>
<td>没有方法体，属于一个抽象类</td>
</tr>
<tr>
<td>final</td>
<td>子类不能覆盖它</td>
</tr>
<tr>
<td>static</td>
<td>被绑定于类本身而不是类的实例</td>
</tr>
<tr>
<td>native</td>
<td>该方法由其他编程语言实现</td>
</tr>
<tr>
<td>asnchronized</td>
<td>在一个线程调用它之前必须先给它加</td>
</tr>
</tbody>
</table>
<p>类的修饰符整合</p>
<p>类</p>
<p>类的修饰符：</p>
<p>Public:可以在其他任何类中使用，默认为统一包下的任意类。</p>
<p>Abstract:抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。</p>
<p>Final:不能被继承。</p>
<p>变量</p>
<p>变量修饰符：</p>
<p>一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。</p>
<p>可访问修饰符：</p>
<p>static**：**类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。</p>
<p>final**：**常量。</p>
<p>volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。</p>
<p>实例变量：和类变量对应，即每个对象都拥有各自独立的实例变量。</p>
<p>方法：（和变量对象分为实例方法和类方法，并用有无static修饰区别）</p>
<p>类方法：使用static关键字说明的方法</p>
<p>1.第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。</p>
<p>2.类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。</p>
<p>实例方法：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。</p>
<p>方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）</p>
<p>方法的返回类型：若无返回类型，则声明为void.</p>
<p>方法中的变量作用域：</p>
<p>成员变量：整个类。</p>
<p>局部变量：定义起到方法块结束为止。</p>
<p>方法参数：整个方法或者构造方法。</p>
<p>异常处理参数：参数传递给异常处理方法。</p>
<p>构造方法：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。</p>
<p>静态初始化器：格式：static{&lt;赋值语句组&gt;}</p>
<p>静态初始化器与构造方法的区别：</p>
<table>
<thead>
<tr>
<th>静态初始化器</th>
<th>构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>对类的静态域初始化</td>
<td>对新建的对象初始化</td>
</tr>
<tr>
<td>类进入内存后，系统调用执行</td>
<td>执行new后自动执行</td>
</tr>
<tr>
<td>属特殊语句（仅执行一次）</td>
<td>属特殊方法</td>
</tr>
</tbody>
</table>
<p>方法的修饰符：</p>
<p>抽象方法：用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。</p>
<p>类方法：静态方法，用static修饰，</p>
<p>调用时，使用类名作为前缀，而不是类的某个实例对象名</p>
<p>不能被单独对象拥有，属于整个类共享。</p>
<p>不能处理成员变量。</p>
<p>最终方法：用final修饰，不能被子类重新定义的方法。</p>
<p>本地方法：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。</p>
<p>Java访问控制符的含义和使用情况</p>
<table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>java自动装箱，对于Integer和Double的自动装箱，只能装对应的数据类型，不对应就会报错。java中100默认是int型,而不是byte，short和long;100.0默认是double，而不是float。</p>
<p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p>
<p>AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。<br>
AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象 ，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。<br>
核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉， AOP只是OOP的补充，无替代关系。</p>
<figure data-type="image" tabindex="10"><img src="https://clownjerome.github.io/post-images/1633677626834.png" alt="" loading="lazy"></figure>
<p>Java中的四类八种基本数据类型</p>
<p>第一类：整数类型  byte short int long</p>
<p>第二类：浮点型  float double</p>
<p>第三类：逻辑型   boolean(它只有两个值可取true false)</p>
<p>第四类：字符型  char</p>
<p>Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度</p>
<p>start()方法是启动一个线程，此时的线程处于就绪状态，但并不一定就会执行，还需要等待CPU的调度。<br>
run()方法才是线程获得CPU时间，开始执行的点。</p>
<p>实现线程的方法有三种：<br>
第一种：继承Thread类覆盖父类的run()方法   创建子类对象 然后  对象.start();执行线程 run()方法执行<br>
第二种：实现Runnable接口 覆盖接口的run()方法   创建线程对象将子类传入，然后线程对象.start();启动线程  run()方法执行<br>
第三种：实现Callable接口  类似于Runnable接口<br>
Callable与Runnable接口的区别是：<br>
①Callable规定的方法是call()，而Runnable规定的方法是run().<br>
②Callable的任务执行后可返回值，而Runnable的任务是不能返回值的<br>
③call()方法可抛出异常，而run()方法是不能抛出异常的。<br>
④运行Callable任务可拿到一个Future对象，Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成,并检索计算的结果。通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果</p>
<p>throws 和 throw：</p>
<p>throws出现在方法头，表示可能会出现异常</p>
<p>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p>
<p>inputstream的close方法用来关闭流</p>
<p>skip()用来跳过一些字节</p>
<p>mark（）用来标记流</p>
<p>reset（）复位流</p>
<p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p>
<p>补充：</p>
<p>​          什么是类加载器？</p>
<p>​    把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>有哪些类加载器，分别加载哪些类</p>
<p>​    类加载器按照层次，从顶层到底层，分为以下三种：</p>
<p>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类</p>
<p>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p>
<p>(3)    应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p>
<p>​          双亲委派模型</p>
<p>​    我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为类加载器的双亲委派模型，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。</p>
<p>​          双亲委托模型的工作原理</p>
<p>​    是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p>
<p>​          使用双亲委派模型好处？（原因）</p>
<p>​    第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>​    第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器</p>
<p>（1）父类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（2）子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。</p>
<p>（3）父类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（4）执行父类构造方法。</p>
<p>（5）子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。</p>
<p>（6）执行子类构造方法</p>
<p>Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点。</p>
<p>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</p>
<p>(1)加载：Servlet容器（Tomcat）通过类加载器加载servlet文件（.class）</p>
<p>(2)创建：通过调用servlet构造函数创建一个servlet对象</p>
<p>(3)初始化：调用init方法初始化</p>
<p>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求</p>
<p>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>
<p>servlet是由Servlet容器负责加载Servlet类，创建Servlet对象并实例化，然后调用Servlet的init方法，进行初始化，之后调用Service方法。实例化和初始化不同。先实例化，再初始化。</p>
<p>再说一下ServletConfig和ServletContext</p>
<p>Jsp/Servlet容器初始化一个Servlet类型的对象时，会为这个Servlet对象创建一个ServletConfig对象。在ServletConfig对象中包含了Servlet的初始化参数信息。</p>
<p>ServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Webapp时，会为它创建一个ServletContext对象，即servlet上下文环境。每个webapp都有唯一的ServletContext对象。同一个webapp的所有servlet对象共享一个ServeltContext，servlet对象可以通过ServletContext来访问容器中的各种资源。</p>
<p>从作用范围来说，ServletConfig作用于某个特定的Servlet，即从该Servlet实例化，那么就开始有效，但是该Servlet之外的其他Servlet不能访问；ServletContext作用于某个webapp，即在一个webapp中相当于一个全局对象，在Servlet容器启动时就已经加载，对于不同的webapp，有不同的ServletContext。</p>
<p>最后，说明一下参数的获取。访问ServletConfig参数，取得ServletConfig对象后，调用getInitParameter()方法;访问ServletContext对象，只要调用现有的ServletConfig对象的getServletContext()即可，然后同样调用getInitParamter()方法就能获取参数。</p>
<figure data-type="image" tabindex="11"><img src="https://clownjerome.github.io/post-images/1633677569488.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://clownjerome.github.io/post-images/1633677561877.png" alt="" loading="lazy"></figure>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://clownjerome.github.io/tag/NnPNjagHY/" class="tag">
                    琐碎知识点
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://clownjerome.github.io/post/hello-world/">
                  <h3 class="post-title">
                    Hello World
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
